
================================================================================
File: agreements.sql
Size: 9.2 kB
================================================================================

-- Agreements table definition
CREATE TABLE agreements
(
    id                         UUID PRIMARY KEY                                                       DEFAULT uuid_generate_v4(),
    user_id                    UUID REFERENCES auth.users (id) ON DELETE RESTRICT,
    headquarter_id             UUID REFERENCES headquarters (id) ON DELETE RESTRICT NOT NULL,
    season_id                  UUID REFERENCES seasons (id)                         NOT NULL,
    role_id                    UUID                                                 NOT NULL REFERENCES roles (id) ON DELETE RESTRICT,
    status                     TEXT CHECK (status IN ('active', 'inactive', 'prospect', 'graduated')) DEFAULT 'prospect',
    email                      TEXT                                                 NOT NULL,
    document_number            TEXT,
    phone                      TEXT,
    created_at                 TIMESTAMPTZ                                                            DEFAULT NOW(),
    updated_at                 TIMESTAMPTZ                                                            DEFAULT NOW(),
    name                       TEXT,
    last_name                  TEXT,
    address                    TEXT,
    activation_date            TIMESTAMPTZ,
    volunteering_agreement     BOOLEAN                                                                DEFAULT FALSE,
    ethical_document_agreement BOOLEAN                                                                DEFAULT FALSE,
    mailing_agreement          BOOLEAN                                                                DEFAULT FALSE,
    age_verification           BOOLEAN                                                                DEFAULT FALSE,
    signature_data             TEXT,
    birth_date                 DATE,
    gender                     TEXT CHECK (gender IN ('male', 'female', 'other', 'unknown'))          DEFAULT 'unknown',
    fts_name_lastname          tsvector,
    UNIQUE (user_id, season_id)
);

COMMENT ON TABLE agreements IS 'Table containing user agreements for seasons';
COMMENT ON COLUMN agreements.user_id IS 'User ID of the user';
COMMENT ON COLUMN agreements.headquarter_id IS 'Headquarter ID of the headquarter';
COMMENT ON COLUMN agreements.season_id IS 'Season ID of the season';
COMMENT ON COLUMN agreements.role_id IS 'Role ID of the role';
COMMENT ON COLUMN agreements.status IS 'Status of the agreement';
COMMENT ON COLUMN agreements.email IS 'Email of the user';
COMMENT ON COLUMN agreements.document_number IS 'Document number of the user';
COMMENT ON COLUMN agreements.phone IS 'Phone of the user';
COMMENT ON COLUMN agreements.created_at IS 'When the record was created';
COMMENT ON COLUMN agreements.updated_at IS 'When the record was last updated';
COMMENT ON COLUMN agreements.name IS 'Name of the user';
COMMENT ON COLUMN agreements.last_name IS 'Last name of the user';
COMMENT ON COLUMN agreements.address IS 'Address of the user';
COMMENT ON COLUMN agreements.activation_date IS 'Activation date of the user when the responsible approves from prospect to active';
COMMENT ON COLUMN agreements.volunteering_agreement IS 'Volunteering agreement of the user';
COMMENT ON COLUMN agreements.ethical_document_agreement IS 'Ethical document agreement of the user';
COMMENT ON COLUMN agreements.mailing_agreement IS 'Mailing agreement of the user';
COMMENT ON COLUMN agreements.age_verification IS 'Age verification of the user';
COMMENT ON COLUMN agreements.signature_data IS 'Signature data of the user';
COMMENT ON COLUMN agreements.birth_date IS 'Birth date of the user';
COMMENT ON COLUMN agreements.gender IS 'Gender of the user, male, other, female, unknown';
COMMENT ON COLUMN agreements.fts_name_lastname IS 'Full-text search vector for name and last name';


CREATE OR REPLACE FUNCTION set_activation_date_on_update()
    RETURNS TRIGGER AS
$$
BEGIN
    IF OLD.status = 'prospect' AND NEW.status = 'active' AND NEW.activation_date IS NULL THEN
        NEW.activation_date := NOW();
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION update_fts_name_lastname()
    RETURNS TRIGGER AS
$$
BEGIN
    NEW.fts_name_lastname :=
            to_tsvector('simple', coalesce(NEW.name, '') || ' ' || coalesce(NEW.last_name, ''));
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;


CREATE TRIGGER handle_updated_at_agreements
    BEFORE UPDATE
    ON agreements
    FOR EACH ROW
EXECUTE PROCEDURE moddatetime(updated_at);

CREATE TRIGGER handle_activation_date
    BEFORE UPDATE
    ON agreements
    FOR EACH ROW
    WHEN (OLD.status IS DISTINCT FROM NEW.status)
EXECUTE FUNCTION set_activation_date_on_update();

CREATE TRIGGER handle_fts_name_lastname_update
    BEFORE INSERT OR UPDATE OF name, last_name
    ON agreements
    FOR EACH ROW
EXECUTE FUNCTION update_fts_name_lastname();

CREATE INDEX idx_agreements_user_id ON agreements (user_id);
CREATE INDEX idx_agreements_headquarter_id ON agreements (headquarter_id);
CREATE INDEX idx_agreements_season_id ON agreements (season_id);
CREATE INDEX idx_agreements_role_id ON agreements (role_id);
CREATE INDEX idx_agreements_email ON agreements (email);
CREATE INDEX idx_agreements_name ON agreements (name);
CREATE INDEX idx_agreements_last_name ON agreements (last_name);
CREATE INDEX idx_agreements_fts_name_lastname ON agreements USING gin (fts_name_lastname);

ALTER TABLE agreements
    ENABLE ROW LEVEL SECURITY;

-- SELECT: Own record, general director+ or local manager+ in same HQ
CREATE POLICY agreements_select_own_hq_high
    ON agreements FOR SELECT
    USING (
    user_id = (select auth.uid()) OR -- Own record
    fn_is_general_director_or_higher() OR
    (fn_is_local_manager_or_higher() AND
     fn_is_current_user_hq_equal_to(headquarter_id)) -- Manager + in same HQ
    );

-- INSERT (anon): Allow anonymous and authenticated users to create prospects
CREATE POLICY agreements_insert_anon_prospect
    ON agreements FOR INSERT
    TO anon, authenticated
    WITH CHECK (status = 'prospect');


-- Drop the existing policy before creating the updated one
DROP POLICY IF EXISTS agreements_update_permissions ON agreements;

-- Consolidated policy for updating agreements based on user-role and target record
CREATE POLICY agreements_update_permissions ON agreements FOR UPDATE
    USING (
    -- Determine which rows an updater can potentially target:
    -- 1. Users can target their own record for update
    user_id =(select auth.uid()) OR
        -- 2. General Directors+ can target any record
    fn_is_general_director_or_higher() OR
        -- 3. Local Managers+ can target records within their own headquarter
    (fn_is_local_manager_or_higher() AND fn_is_current_user_hq_equal_to(headquarter_id))
    )
    WITH CHECK (
    -- Define the conditions the NEW row must satisfy based on the updater's role.

    -- Universal Restrictions: Regardless of who is updating, these fields cannot be changed.
    user_id = user_id AND
    headquarter_id = headquarter_id AND
    email = email AND -- Email cannot be changed via this table's update

    -- Role-Specific Restrictions:
    (
        -- CASE 1: General Director+ is updating
        -- They are subject only to the universal restrictions above.
        fn_is_general_director_or_higher()
        )
        OR
    (
        -- CASE 2: User is updating their own record (and is NOT GD+)
        user_id =(select auth.uid()) AND
        NOT fn_is_general_director_or_higher() AND
            -- Must also not change their own role_id (in addition to universal restrictions)
        role_id = role_id
        -- Can update other fields like status, phone, address, agreements, signature, etc.
        )
        OR
    (
        -- CASE 3: Local Manager+ is updating someone else in their HQ (and is NOT GD+).
        -- Check current user is LM+ (not GD+) and is NOT the owner.
        user_id <>(select auth.uid()) AND
        fn_is_local_manager_or_higher() AND
        NOT fn_is_general_director_or_higher() AND
            -- Additional restriction: cannot assign roles with level 95 or higher.
        NOT EXISTS (SELECT 1
                    FROM public.roles -- Using EXISTS for clarity and performance
                    WHERE id = role_id
                      AND level >= 95)
        )
    );

-- Update the comment to reflect the applied restrictions
COMMENT ON POLICY agreements_update_permissions ON agreements IS
    'Defines update permissions for the agreements table:
    Universal Restrictions: user_id, headquarter_id, and email cannot be changed by any user via this policy.
    Role-Specific Logic:
    1. General Directors (or higher roles) can update any record, subject only to universal restrictions.
    2. Regular users (non-GD+) can update their own agreement, but cannot change their user_id, role_id, headquarter_id, or email.
    3. Local Managers (or higher, but non-GD+) can update records in their HQ (excluding themselves). They cannot change user_id, headquarter_id, or email, and cannot assign roles with level >= 95.';

-- DELETE: General Director+ only
CREATE POLICY agreements_delete_admin
    ON agreements FOR DELETE
    USING (fn_is_general_director_or_higher());


================================================================================
File: agreement_with_role.sql
Size: 5.95 kB
================================================================================

/*
 * 
 * Functions:
 * - get_agreements_with_role(): Returns all agreements with their role
 * - get_agreements_by_role(role_name TEXT): Returns agreements filtered by role name
 * - get_agreement_by_role_id(role_id UUID): Returns agreements filtered by role ID
 * - get_agreements_by_role_string(role_string TEXT): Returns agreements filtered by a string that matches role name or code
 * - get_agreements_with_role_paginated(...): Returns paginated and filtered agreements with pagination metadata
 * - get_agreement_with_role_by_id(p_agreement_id UUID): Returns a single agreement by ID
 * 
 * Usage examples:
 * - SELECT * FROM get_agreements_with_role();
 * - SELECT * FROM get_agreements_by_role('Student');
 * - SELECT * FROM get_agreement_by_role_id('123e4567-e89b-12d3-a456-426614174000');
 * - SELECT * FROM get_agreements_by_role_string('admin');
 * - SELECT get_agreements_with_role_paginated(10, 0, 'active', NULL, NULL, 'john', NULL);
 * - SELECT get_agreement_with_role_by_id('123e4567-e89b-12d3-a456-426614174000');
 */

create view public.agreement_with_role as
SELECT a.id,
       a.user_id,
       a.headquarter_id,
       a.season_id,
       a.status,
       a.email,
       a.document_number,
       a.phone,
       a.name,
       a.last_name,
       a.fts_name_lastname,
       a.address,
       a.signature_data,
       a.volunteering_agreement,
       a.ethical_document_agreement,
       a.mailing_agreement,
       a.age_verification,
       a.created_at,
       a.updated_at,
       COALESCE(jsonb_build_object('role_id', r.id, 'role_name', r.name, 'role_description', r.description, 'role_code', r.code, 'role_level', r.level), '{}'::jsonb) AS role
FROM agreements a
         LEFT JOIN roles r ON a.role_id = r.id;

ALTER VIEW agreement_with_role SET (security_invoker = on);

CREATE OR REPLACE FUNCTION get_agreements_with_role()
RETURNS SETOF agreement_with_role
LANGUAGE sql
SECURITY INVOKER
SET search_path = ''
AS $$
  SELECT * FROM public.agreement_with_role;
$$;

CREATE OR REPLACE FUNCTION get_agreements_by_role(role_name TEXT)
RETURNS SETOF agreement_with_role
LANGUAGE sql
SECURITY INVOKER
SET search_path = ''
AS $$
  SELECT awr.*
  FROM public.agreement_with_role awr
  WHERE awr.role->>'role_name' = role_name;
$$;

CREATE OR REPLACE FUNCTION get_agreement_by_role_id(role_id UUID)
RETURNS SETOF agreement_with_role
LANGUAGE sql
SECURITY INVOKER
SET search_path = ''
AS $$
  SELECT awr.*
  FROM public.agreement_with_role awr
  WHERE awr.role->>'role_id' = role_id::text;
$$;

CREATE OR REPLACE FUNCTION get_agreements_by_role_string(role_string TEXT)
RETURNS SETOF agreement_with_role
LANGUAGE sql
SECURITY INVOKER
SET search_path = ''
AS $$
  SELECT awr.*
  FROM public.agreement_with_role awr
  WHERE awr.role->>'role_name' ILIKE '%' || role_string || '%'
  OR awr.role->>'role_id' IN (
    SELECT r.id::text
    FROM public.roles r
    WHERE r.code ILIKE '%' || role_string || '%'
  );
$$;

-- Updated to use FTS for name/last_name search and window function for count
-- See review notes for rationale and performance considerations
CREATE OR REPLACE FUNCTION get_agreements_with_role_paginated(
  p_limit INTEGER DEFAULT 10,
  p_offset INTEGER DEFAULT 0,
  p_status TEXT DEFAULT NULL,
  p_headquarter_id UUID DEFAULT NULL,
  p_season_id UUID DEFAULT NULL,
  p_search TEXT DEFAULT NULL,
  p_role_id UUID DEFAULT NULL
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY INVOKER
SET search_path = ''
AS $$
DECLARE
  v_total BIGINT;
  v_results JSONB;
  v_data JSONB;
BEGIN
  SELECT COUNT(*) INTO v_total
  FROM public.agreement_with_role awr
  WHERE 
    (p_status IS NULL OR awr.status = p_status)
    AND (p_headquarter_id IS NULL OR awr.headquarter_id = p_headquarter_id)
    AND (p_season_id IS NULL OR awr.season_id = p_season_id)
    AND (p_search IS NULL OR 
         awr.name ILIKE '%' || p_search || '%' OR 
         awr.last_name ILIKE '%' || p_search || '%' OR
         awr.email ILIKE '%' || p_search || '%' OR
         awr.document_number ILIKE '%' || p_search || '%')
    AND (p_role_id IS NULL OR awr.role->>'role_id' = p_role_id::text);

  SELECT jsonb_agg(to_jsonb(awr)) INTO v_data
  FROM (
    SELECT *
    FROM public.agreement_with_role awr
    WHERE 
      (p_status IS NULL OR awr.status = p_status)
      AND (p_headquarter_id IS NULL OR awr.headquarter_id = p_headquarter_id)
      AND (p_season_id IS NULL OR awr.season_id = p_season_id)
      AND (p_search IS NULL OR 
           awr.name ILIKE '%' || p_search || '%' OR 
           awr.last_name ILIKE '%' || p_search || '%' OR
           awr.email ILIKE '%' || p_search || '%' OR
           awr.document_number ILIKE '%' || p_search || '%')
      AND (p_role_id IS NULL OR awr.role->>'role_id' = p_role_id::text)
    ORDER BY awr.created_at DESC
    LIMIT p_limit
    OFFSET p_offset
  ) awr;

  -- Handle case when no results are found
  IF v_data IS NULL THEN
    v_data := '[]'::jsonb;
  END IF;

  -- Construct the final result object
  v_results := jsonb_build_object(
    'data', v_data,
    'pagination', jsonb_build_object(
      'total', v_total,
      'limit', p_limit,
      'offset', p_offset,
      'page', CASE WHEN p_limit > 0 THEN (p_offset / p_limit) + 1 ELSE 1 END,
      'pages', CASE WHEN p_limit > 0 THEN CEIL(v_total::numeric / p_limit::numeric) ELSE 1 END
    )
  );

  RETURN v_results;
END;
$$;

CREATE OR REPLACE FUNCTION get_agreement_with_role_by_id(p_agreement_id UUID)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY INVOKER
SET search_path = ''
AS $$
DECLARE
  v_result JSONB;
BEGIN
  SELECT to_jsonb(awr) INTO v_result
  FROM public.agreement_with_role awr
  WHERE awr.id = p_agreement_id;

  IF v_result IS NULL THEN
    RETURN jsonb_build_object('error', 'Agreement not found');
  END IF;

  RETURN v_result;
END;
$$;


================================================================================
File: audit.sql
Size: 2.86 kB
================================================================================

/* ---------- 1)  Generic audit table ---------- */
CREATE TABLE audit_log (
  id            bigserial PRIMARY KEY,
  table_name    text,
  action        text,          -- 'INSERT' | 'UPDATE' | 'DELETE'
  record_id     uuid,
  changed_by    uuid,
  user_name     text,
  changed_at    timestamptz DEFAULT now(),
  diff          jsonb
);

/* ---------- 2)  Re-usable trigger function ---------- */
-- SECURITY DEFINER: This function runs with elevated privileges. It is required for audit logging but must be maintained with care.
CREATE OR REPLACE FUNCTION trg_audit()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = ''
AS $$
DECLARE
  user_email text;
BEGIN
  -- Get the user's email for better readability in audit logs
  SELECT email INTO user_email FROM auth.users WHERE id = auth.uid();

  IF (TG_OP = 'DELETE') THEN
    INSERT INTO public.audit_log(table_name, action, record_id, changed_by, user_name, diff)
    VALUES (TG_TABLE_NAME, TG_OP, OLD.id, auth.uid(), user_email, to_jsonb(OLD));
    RETURN OLD;
  ELSIF (TG_OP = 'UPDATE') THEN
    INSERT INTO public.audit_log(table_name, action, record_id, changed_by, user_name, diff)
    VALUES (TG_TABLE_NAME, TG_OP, NEW.id, auth.uid(), user_email,
            jsonb_build_object('old', to_jsonb(OLD), 'new', to_jsonb(NEW)));
    RETURN NEW;
  ELSE  -- INSERT
    INSERT INTO public.audit_log(table_name, action, record_id, changed_by, user_name, diff)
    VALUES (TG_TABLE_NAME, TG_OP, NEW.id, auth.uid(), user_email, to_jsonb(NEW));
    RETURN NEW;
  END IF;
END;
$$;

GRANT EXECUTE ON FUNCTION trg_audit() TO authenticated;

/* ---------- 3)  Attach trigger to critical tables ---------- */
DO $$
DECLARE
  t text;
BEGIN
  FOREACH t IN ARRAY ARRAY['agreements','students','collaborators','headquarters','countries','seasons','scheduled_workshops']
  LOOP
    EXECUTE format('
      DROP TRIGGER IF EXISTS audit_%I ON %I;
      CREATE TRIGGER audit_%I
      AFTER INSERT OR UPDATE OR DELETE ON %I
      FOR EACH ROW EXECUTE PROCEDURE trg_audit();',
      t, t, t, t);
  END LOOP;
END;
$$;


ALTER TABLE audit_log ENABLE ROW LEVEL SECURITY;

-- SELECT: Allow only General Director+ (95+)
CREATE POLICY audit_select_high_level
ON audit_log FOR SELECT
TO authenticated
USING ( fn_is_general_director_or_higher() );

-- INSERT: Allow only General Director+ (95+)
CREATE POLICY audit_insert_high_level
ON audit_log FOR INSERT
TO authenticated
WITH CHECK ( fn_is_general_director_or_higher() );

-- UPDATE: Allow only General Director+ (95+)
CREATE POLICY audit_update_high_level
ON audit_log FOR UPDATE
TO authenticated
USING ( fn_is_general_director_or_higher() )
WITH CHECK ( fn_is_general_director_or_higher() );

-- DELETE: Allow only General Director+ (95+)
CREATE POLICY audit_delete_high_level
ON audit_log FOR DELETE
TO authenticated
USING ( fn_is_general_director_or_higher() );


================================================================================
File: collaborators.sql
Size: 2.69 kB
================================================================================

CREATE TYPE collaborator_status AS ENUM ('active', 'inactive', 'standby');

-- Collaborators table definition
CREATE TABLE collaborators (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL UNIQUE REFERENCES auth.users(id) ON DELETE CASCADE,
    role_id UUID NOT NULL REFERENCES roles(id) ON DELETE RESTRICT ,
    headquarter_id UUID NOT NULL REFERENCES headquarters(id) ON DELETE RESTRICT,
    status collaborator_status DEFAULT 'inactive',
    start_date DATE,
    end_date DATE
);

CREATE INDEX idx_collaborators_user_id ON collaborators(user_id);
CREATE INDEX idx_collaborators_role_id ON collaborators(role_id);
CREATE INDEX idx_collaborators_headquarter_id ON collaborators(headquarter_id);

ALTER TABLE collaborators ENABLE ROW LEVEL SECURITY;

-- trigger to ensure collaborator has a valid agreement
CREATE OR REPLACE FUNCTION check_collaborator_has_agreement()
    RETURNS TRIGGER 
    SET search_path = ''
    AS $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM public.agreements WHERE user_id = NEW.user_id) THEN
        RAISE EXCEPTION 'Collaborator must have a valid agreement';
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;


-- Policies for the collaborators table

-- SELECT: Own record, same HQ if level >= 50, any if level >= 90
CREATE POLICY collaborators_select_self_hq_high
ON collaborators FOR SELECT
USING (
    user_id = (select auth.uid()) OR
    (fn_is_local_manager_or_higher() AND fn_is_current_user_hq_equal_to(headquarter_id)) OR
    fn_is_general_director_or_higher()
);

-- INSERT: Manager+ for own HQ, Director+ for any HQ/role
CREATE POLICY collaborators_insert_manager_director
ON collaborators FOR INSERT
WITH CHECK (
    (
        fn_is_local_manager_or_higher()
        AND fn_is_current_user_hq_equal_to(headquarter_id)
    )
    OR fn_is_general_director_or_higher()
);

-- UPDATE: Own record, manager+ for own HQ (only roles <95), director+ for any
CREATE POLICY collaborators_update_self_manager_director
ON collaborators FOR UPDATE
USING (
    user_id = (select auth.uid()) OR
    (fn_is_local_manager_or_higher() AND fn_is_current_user_hq_equal_to(headquarter_id)) OR
    fn_is_general_director_or_higher()
)
WITH CHECK (
    user_id = (select auth.uid())
    OR (
        fn_is_local_manager_or_higher()
        AND fn_is_current_user_hq_equal_to(headquarter_id)
        AND (SELECT level FROM roles WHERE id = role_id) < 95
        )
    OR fn_is_general_director_or_higher()
);

-- DELETE: Director+ only
CREATE POLICY general_director_can_delete_collaborators
ON collaborators FOR DELETE
USING ( fn_is_general_director_or_higher() );


================================================================================
File: companion_student_map.sql
Size: 4.78 kB
================================================================================

-- schemas/companion_student_map.sql

CREATE TABLE companion_student_map (
    companion_id uuid NOT NULL REFERENCES collaborators(user_id) ON DELETE CASCADE,
    student_id uuid NOT NULL REFERENCES students(user_id) ON DELETE CASCADE,
    season_id uuid NOT NULL REFERENCES seasons(id) ON DELETE CASCADE,
    headquarter_id uuid NOT NULL REFERENCES headquarters(id) ON DELETE RESTRICT, 
    created_at timestamptz DEFAULT now() NOT NULL,
    updated_at timestamptz,
    CONSTRAINT companion_student_map_pkey PRIMARY KEY (companion_id, student_id, season_id) -- PK ensures uniqueness per season
);

-- TRIGGER: Enforce HQ consistency between mapping, companion, and student for the given season
CREATE OR REPLACE FUNCTION check_companion_student_hq_consistency()
RETURNS TRIGGER 
SET search_path = ''
AS $$
DECLARE
    companion_hq_id UUID;
    student_hq_id UUID;
BEGIN
    -- Get companion's HQ for the relevant season
    SELECT a.headquarter_id INTO companion_hq_id
    FROM public.agreements a
    WHERE a.user_id = NEW.companion_id AND a.season_id = NEW.season_id
    LIMIT 1;

    -- Get student's HQ for the relevant season
    SELECT a.headquarter_id INTO student_hq_id
    FROM public.agreements a
    WHERE a.user_id = NEW.student_id AND a.season_id = NEW.season_id
    LIMIT 1;

    IF NEW.headquarter_id IS DISTINCT FROM companion_hq_id THEN
        RAISE EXCEPTION 'Companion HQ (%) does not match mapping HQ (%) for season %', companion_hq_id, NEW.headquarter_id, NEW.season_id;
    END IF;
    IF NEW.headquarter_id IS DISTINCT FROM student_hq_id THEN
        RAISE EXCEPTION 'Student HQ (%) does not match mapping HQ (%) for season %', student_hq_id, NEW.headquarter_id, NEW.season_id;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY INVOKER;

CREATE TRIGGER ensure_companion_student_hq_consistency
    BEFORE INSERT OR UPDATE ON companion_student_map
    FOR EACH ROW EXECUTE FUNCTION check_companion_student_hq_consistency();



COMMENT ON TABLE companion_student_map IS 'Maps companions to students for a specific season and headquarter.';
COMMENT ON COLUMN companion_student_map.season_id IS 'The season this mapping belongs to.';
COMMENT ON COLUMN companion_student_map.headquarter_id IS 'The headquarter this mapping belongs to (should match student''s HQ).';

CREATE INDEX idx_companion_student_map_companion_id ON companion_student_map(companion_id);
CREATE INDEX idx_companion_student_map_student_id ON companion_student_map(student_id);
CREATE INDEX idx_companion_student_map_season_id ON companion_student_map(season_id);
CREATE INDEX idx_companion_student_map_headquarter_id ON companion_student_map(headquarter_id);
CREATE INDEX idx_companion_student_map_agreement_id ON companion_student_map(headquarter_id, season_id);

CREATE TRIGGER handle_updated_at BEFORE UPDATE ON companion_student_map
  FOR EACH ROW EXECUTE PROCEDURE moddatetime (updated_at);

ALTER TABLE companion_student_map ENABLE ROW LEVEL SECURITY;

-- SELECT Policy:
-- Companion sees their own maps.
-- Manager Assistant+  sees all maps for their HQ (all seasons).
-- Director+  sees all maps for all HQs (all seasons).
CREATE POLICY select_companion_map
ON companion_student_map FOR SELECT
USING (
    (select auth.uid()) = companion_id
    OR
    (fn_is_manager_assistant_or_higher() AND headquarter_id = fn_get_current_hq_id())
    OR
    fn_is_general_director_or_higher()
);

-- INSERT Policy:
-- Manager Assistant+ can insert maps for their HQ.
-- Director+ can insert maps for any HQ.
CREATE POLICY insert_companion_map
ON companion_student_map FOR INSERT
WITH CHECK (
    (fn_is_manager_assistant_or_higher() AND headquarter_id = fn_get_current_hq_id())
    OR
    fn_is_general_director_or_higher()
);

-- UPDATE Policy:
-- Manager Assistant+ can update maps for their HQ.
-- Director+ can update maps for any HQ.
-- Prevent changing key identifiers like student_id, companion_id, season_id, headquarter_id unless Director+
CREATE POLICY update_companion_map
ON companion_student_map FOR UPDATE
USING (
    (fn_is_manager_assistant_or_higher() AND headquarter_id = fn_get_current_hq_id())
    OR
    fn_is_general_director_or_higher()
)
WITH CHECK (
    -- Ensure the HQ isn't changed unless by Director+
    (headquarter_id =headquarter_id AND season_id = season_id) -- Manager+ can only update within existing HQ/Season context
    OR
    fn_is_general_director_or_higher() -- Director+ can change anything (potentially)
);


-- DELETE Policy:
-- Manager Assistant+ can delete maps from their HQ.
-- Director+ can delete maps from any HQ.
CREATE POLICY delete_companion_map
ON companion_student_map FOR DELETE
USING (
    (fn_is_manager_assistant_or_higher() AND headquarter_id = fn_get_current_hq_id())
    OR
    fn_is_general_director_or_higher()
);


================================================================================
File: countries.sql
Size: 1.42 kB
================================================================================

-- Countries table definition
CREATE TABLE countries
(
    id         UUID PRIMARY KEY                              DEFAULT uuid_generate_v4(),
    name       TEXT NOT NULL,
    code       TEXT NOT NULL UNIQUE,
    status     TEXT CHECK (status IN ('active', 'inactive')) DEFAULT 'active', -- SUGGESTION: Consider ENUM for status for type safety.
    created_at TIMESTAMPTZ                                   DEFAULT NOW(),
    updated_at TIMESTAMPTZ                                   DEFAULT NOW()
);

CREATE TRIGGER handle_updated_at_countries
    BEFORE UPDATE
    ON countries
    FOR EACH ROW
EXECUTE PROCEDURE moddatetime(updated_at);

CREATE INDEX idx_countries_code ON countries (code); -- Support fast lookup by code

ALTER TABLE countries
    ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Allow authenticated users to view countries"
    ON countries
    FOR SELECT
    TO authenticated
    USING (true);

CREATE POLICY "Allow super admin to insert countries"
    ON countries
    FOR INSERT
    TO authenticated
    WITH CHECK (fn_is_super_admin());

CREATE POLICY "Allow super admin to update countries"
    ON countries
    FOR UPDATE
    TO authenticated
    USING (fn_is_super_admin())
    WITH CHECK (fn_is_super_admin());

CREATE POLICY "Allow super admin to delete countries"
    ON countries
    FOR DELETE
    TO authenticated
    USING (fn_is_super_admin());


================================================================================
File: dashboard_functions.sql
Size: 93.15 kB
================================================================================

-- Functions for dashboard statistics

CREATE OR REPLACE FUNCTION get_dashboard_agreement_review_statistics()
    RETURNS jsonb
    LANGUAGE plpgsql
    SECURITY INVOKER
    SET search_path = ''
AS
$$
DECLARE
    result jsonb;
BEGIN
    result := jsonb_build_object(
            'students', (WITH stats
                                  AS (SELECT COUNT(*)
                                             FILTER (WHERE a.status = 'prospect' AND r.code = 'student')  AS pending,
                                             COUNT(*)
                                             FILTER (WHERE a.status != 'prospect' AND r.code = 'student') AS reviewed,
                                             COUNT(*) FILTER (WHERE r.code = 'student')                   AS total
                                      FROM public.agreements a
                                               JOIN public.roles r ON a.role_id = r.id)
                         SELECT jsonb_build_object(
                                        'pending', pending,
                                        'reviewed', reviewed,
                                        'total', total,
                                        'percentage_reviewed', CASE
                                                                   WHEN total > 0
                                                                       THEN ROUND((reviewed::numeric / total::numeric) * 100, 2)
                                                                   ELSE 0
                                            END
                                )
                         FROM stats),
            'collaborators', (WITH stats
                                       AS (SELECT COUNT(*)
                                                  FILTER (WHERE a.status = 'prospect' AND r.level >= 10 AND r.level < 50)  AS pending,
                                                  COUNT(*)
                                                  FILTER (WHERE a.status != 'prospect' AND r.level >= 10 AND r.level < 50) AS reviewed,
                                                  COUNT(*) FILTER (WHERE r.level >= 10 AND r.level < 50)                   AS total
                                           FROM public.agreements a
                                                    JOIN public.roles r ON a.role_id = r.id)
                              SELECT jsonb_build_object(
                                             'pending', pending,
                                             'reviewed', reviewed,
                                             'total', total,
                                             'percentage_reviewed', CASE
                                                                        WHEN total > 0
                                                                            THEN ROUND((reviewed::numeric / total::numeric) * 100, 2)
                                                                        ELSE 0
                                                 END
                                     )
                              FROM stats),
            'konsejo_members', (WITH stats
                                         AS (SELECT COUNT(*)
                                                    FILTER (WHERE a.status = 'prospect' AND r.level >= 80)  AS pending,
                                                    COUNT(*)
                                                    FILTER (WHERE a.status != 'prospect' AND r.level >= 80) AS reviewed,
                                                    COUNT(*) FILTER (WHERE r.level >= 80)                   AS total
                                             FROM public.agreements a
                                                      JOIN public.roles r ON a.role_id = r.id)
                                SELECT jsonb_build_object(
                                               'pending', pending,
                                               'reviewed', reviewed,
                                               'total', total,
                                               'percentage_reviewed', CASE
                                                                          WHEN total > 0
                                                                              THEN ROUND((reviewed::numeric / total::numeric) * 100, 2)
                                                                          ELSE 0
                                                   END
                                       )
                                FROM stats),
            'directors', (WITH stats
                                   AS (SELECT COUNT(*)
                                              FILTER (WHERE a.status = 'prospect' AND r.level >= 50 AND r.level < 80)  AS pending,
                                              COUNT(*)
                                              FILTER (WHERE a.status != 'prospect' AND r.level >= 50 AND r.level < 80) AS reviewed,
                                              COUNT(*) FILTER (WHERE r.level >= 50 AND r.level < 80)                   AS total
                                       FROM public.agreements a
                                                JOIN public.roles r ON a.role_id = r.id)
                          SELECT jsonb_build_object(
                                         'pending', pending,
                                         'reviewed', reviewed,
                                         'total', total,
                                         'percentage_reviewed', CASE
                                                                    WHEN total > 0
                                                                        THEN ROUND((reviewed::numeric / total::numeric) * 100, 2)
                                                                    ELSE 0
                                             END
                                 )
                          FROM stats),
            'facilitators', (WITH stats
                                      AS (SELECT COUNT(*)
                                                 FILTER (WHERE a.status = 'prospect' AND r.code = 'facilitator')  AS pending,
                                                 COUNT(*)
                                                 FILTER (WHERE a.status != 'prospect' AND r.code = 'facilitator') AS reviewed,
                                                 COUNT(*) FILTER (WHERE r.code = 'facilitator')                   AS total
                                          FROM public.agreements a
                                                   JOIN public.roles r ON a.role_id = r.id)
                             SELECT jsonb_build_object(
                                            'pending', pending,
                                            'reviewed', reviewed,
                                            'total', total,
                                            'percentage_reviewed', CASE
                                                                       WHEN total > 0
                                                                           THEN ROUND((reviewed::numeric / total::numeric) * 100, 2)
                                                                       ELSE 0
                                                END
                                    )
                             FROM stats),
            'companions', (WITH stats
                                    AS (SELECT COUNT(*)
                                               FILTER (WHERE a.status = 'prospect' AND r.code = 'companion')  AS pending,
                                               COUNT(*)
                                               FILTER (WHERE a.status != 'prospect' AND r.code = 'companion') AS reviewed,
                                               COUNT(*) FILTER (WHERE r.code = 'companion')                   AS total
                                        FROM public.agreements a
                                                 JOIN public.roles r ON a.role_id = r.id)
                           SELECT jsonb_build_object(
                                          'pending', pending,
                                          'reviewed', reviewed,
                                          'total', total,
                                          'percentage_reviewed', CASE
                                                                     WHEN total > 0
                                                                         THEN ROUND((reviewed::numeric / total::numeric) * 100, 2)
                                                                     ELSE 0
                                              END
                                  )
                           FROM stats),
            'overall',
            (WITH stats AS (SELECT COUNT(*) FILTER (WHERE a.status = 'prospect')  AS pending,
                                   COUNT(*) FILTER (WHERE a.status != 'prospect') AS reviewed,
                                   COUNT(*)                                       AS total
                            FROM public.agreements a)
             SELECT jsonb_build_object(
                            'pending', pending,
                            'reviewed', reviewed,
                            'total', total,
                            'percentage_reviewed', CASE
                                                       WHEN total > 0
                                                           THEN ROUND((reviewed::numeric / total::numeric) * 100, 2)
                                                       ELSE 0
                                END
                    )
             FROM stats)
              );

    RETURN result;
END;
$$;

GRANT EXECUTE ON FUNCTION get_dashboard_agreement_review_statistics() TO authenticated;

CREATE OR REPLACE FUNCTION get_dashboard_statistics()
    RETURNS jsonb
    LANGUAGE plpgsql
    SECURITY INVOKER
    SET search_path = ''
AS
$$
DECLARE
    result jsonb;
BEGIN
    result := jsonb_build_object(
            'countries', (SELECT jsonb_build_object(
                                         'total', COUNT(*),
                                         'active', COUNT(*) FILTER (WHERE status = 'active'),
                                         'inactive', COUNT(*) FILTER (WHERE status = 'inactive')
                                 )
                          FROM public.countries),
            'headquarters', (SELECT jsonb_build_object(
                                            'total', COUNT(*),
                                            'active', COUNT(*) FILTER (WHERE status = 'active'),
                                            'inactive', COUNT(*) FILTER (WHERE status = 'inactive')
                                    )
                             FROM public.headquarters),
            'collaborators', (SELECT jsonb_build_object(
                                             'total', COUNT(*),
                                             'active', COUNT(*) FILTER (WHERE status = 'active'),
                                             'inactive',
                                             COUNT(*) FILTER (WHERE status = 'inactive'),
                                             'standby', COUNT(*) FILTER (WHERE status = 'standby')
                                     )
                              FROM public.collaborators),
            'students', (SELECT jsonb_build_object(
                                        'total', COUNT(*),
                                        'active', COUNT(*) FILTER (WHERE status = 'active'),
                                        'inactive', COUNT(*) FILTER (WHERE status != 'active')
                                )
                         FROM public.students),
            'konsejo_members', (SELECT jsonb_build_object(
                                               'total', COUNT(*),
                                               'active',
                                               COUNT(*) FILTER (WHERE c.status = 'active'),
                                               'inactive',
                                               COUNT(*) FILTER (WHERE c.status != 'active')
                                       )
                                FROM public.collaborators c
                                         JOIN public.roles r ON c.role_id = r.id
                                WHERE r.level >= 80),
            'directors', (SELECT jsonb_build_object(
                                         'total', COUNT(*),
                                         'active', COUNT(*) FILTER (WHERE c.status = 'active'),
                                         'inactive', COUNT(*) FILTER (WHERE c.status != 'active')
                                 )
                          FROM public.collaborators c
                                   JOIN public.roles r ON c.role_id = r.id
                          WHERE r.level >= 50
                            AND r.level < 80),
            'facilitators', (SELECT jsonb_build_object(
                                            'total', COUNT(*),
                                            'active', COUNT(*) FILTER (WHERE c.status = 'active'),
                                            'inactive', COUNT(*) FILTER (WHERE c.status != 'active')
                                    )
                             FROM public.collaborators c
                                      JOIN public.roles r ON c.role_id = r.id
                             WHERE r.code = 'facilitator'),
            'companions', (SELECT jsonb_build_object(
                                          'total', COUNT(*),
                                          'active', COUNT(*) FILTER (WHERE c.status = 'active'),
                                          'inactive', COUNT(*) FILTER (WHERE c.status != 'active')
                                  )
                           FROM public.collaborators c
                                    JOIN public.roles r ON c.role_id = r.id
                           WHERE r.code = 'companion')
              );

    RETURN result;
END;
$$;

-- Grant execute permission to authenticated users
GRANT EXECUTE ON FUNCTION get_dashboard_statistics() TO authenticated;

-- Function to get global dashboard statistics (accessible only by roles >= 80)
CREATE OR REPLACE FUNCTION get_global_dashboard_stats()
    RETURNS jsonb
    LANGUAGE plpgsql
    SECURITY DEFINER
    SET search_path = ''
AS
$$
DECLARE
    current_role_level          integer;
    total_headquarters          bigint;
    total_collaborators         bigint;
    total_students              bigint;
    total_active_seasons        bigint;
    total_agreements            bigint;
    agreements_prospect         bigint;
    agreements_active           bigint;
    agreements_inactive         bigint;
    agreements_graduated        bigint;
    agreements_this_year        bigint;
    stats                       jsonb;
    total_workshops             bigint;
    total_events                bigint;
    avg_days_prospect_to_active numeric;
BEGIN
    current_role_level := public.fn_get_current_role_level();
    -- Standardized: Only Konsejo Member+ (80+) can access global dashboard stats
    IF current_role_level < 80 THEN
        RAISE EXCEPTION 'Insufficient privileges to access global dashboard statistics. Required level: 80 (Konsejo Member+), Your level: %', current_role_level;
    END IF;

    -- Count headquarters, collaborators, students
    SELECT COUNT(*) INTO total_headquarters FROM public.headquarters WHERE status = 'active';
    SELECT COUNT(*) INTO total_collaborators FROM public.collaborators WHERE status = 'active';
    SELECT COUNT(*) INTO total_students FROM public.students WHERE status = 'active';
    SELECT COUNT(*) INTO total_active_seasons FROM public.seasons WHERE status = 'active';

    -- Count agreements by status
    SELECT COUNT(*)                                                               AS total,
           COUNT(*) FILTER (WHERE status = 'prospect')                            AS prospect,
           COUNT(*) FILTER (WHERE status = 'active')                              AS active,
           COUNT(*) FILTER (WHERE status = 'inactive')                            AS inactive,
           COUNT(*) FILTER (WHERE status = 'graduated')                           AS graduated,
           COUNT(*) FILTER (WHERE created_at >= date_trunc('year', current_date)) AS this_year
    INTO
        total_agreements,
        agreements_prospect,
        agreements_active,
        agreements_inactive,
        agreements_graduated,
        agreements_this_year
    FROM public.agreements;

    -- Count scheduled_workshops and events associated with active seasons
    SELECT COUNT(w.*)
    INTO total_workshops
    FROM public.scheduled_workshops w
             JOIN public.seasons s ON w.season_id = s.id
    WHERE s.status = 'active';

    SELECT COUNT(e.*)
    INTO total_events
    FROM public.events e
             JOIN public.seasons s ON e.season_id = s.id
    WHERE s.status = 'active';
    -- Only count events in currently active seasons

    -- Calculate average time from prospect to active status
    SELECT AVG(EXTRACT(EPOCH FROM (activation_date - created_at)) / 86400.0) -- 86400 seconds in a day
    INTO avg_days_prospect_to_active
    FROM public.agreements
    WHERE status IN ('active', 'graduated')
      AND activation_date IS NOT NULL
      AND created_at IS NOT NULL
      AND activation_date > created_at;

    -- Construct the JSON response
    stats := jsonb_build_object(
            'total_headquarters', total_headquarters,
            'total_collaborators', total_collaborators,
            'total_students', total_students,
            'total_agreements_all_time', total_agreements,
            'total_agreements_prospect', agreements_prospect,
            'total_agreements_active', agreements_active,
            'total_agreements_inactive', agreements_inactive,
            'total_agreements_graduated', agreements_graduated,
            'total_agreements_this_year', agreements_this_year,
            'percentage_agreements_active', CASE
                                                WHEN total_agreements > 0 THEN ROUND(
                                                        (agreements_active::numeric / total_agreements) *
                                                        100, 2)
                                                ELSE 0 END,
            'percentage_agreements_prospect', CASE
                                                  WHEN total_agreements > 0 THEN ROUND(
                                                          (agreements_prospect::numeric / total_agreements) *
                                                          100, 2)
                                                  ELSE 0 END,
            'percentage_agreements_graduated', CASE
                                                   WHEN total_agreements > 0 THEN ROUND(
                                                           (agreements_graduated::numeric / total_agreements) *
                                                           100, 2)
                                                   ELSE 0 END,
            'total_active_seasons', total_active_seasons,
            'total_workshops_active_seasons', total_workshops,
            'total_events_active_seasons', total_events,
            'avg_days_prospect_to_active', COALESCE(ROUND(avg_days_prospect_to_active, 2), 0)
             );

    RETURN stats;
END;
$$;

-- Grant execute permission to authenticated users
-- The permission check is done inside the function
GRANT EXECUTE ON FUNCTION get_global_dashboard_stats() TO authenticated;

-- Function to get dashboard statistics for a specific headquarters
-- Accessible by users belonging to that HQ or roles >= 70
CREATE OR REPLACE FUNCTION get_headquarter_dashboard_stats(target_hq_id uuid)
    RETURNS jsonb -- Changed return type to jsonb for flexibility
    LANGUAGE plpgsql
    SECURITY DEFINER -- Allows bypassing RLS for counting, but we check permission first
    SET search_path = ''
AS
$$
DECLARE
    current_role_level               integer;
    current_user_hq_id               uuid;
    is_authorized                    boolean := false;
    stats                            jsonb;
    -- Counts
    hq_active_students_count         bigint;
    hq_active_collaborators_count    bigint;
    hq_manager_assistants_count      bigint; -- Role Level >= 50
    hq_agreements_total              bigint;
    hq_agreements_prospect           bigint;
    hq_agreements_active             bigint;
    hq_agreements_inactive           bigint;
    hq_agreements_graduated          bigint;
    hq_agreements_this_year          bigint;
    hq_agreements_last_3_months      bigint;
    -- Distributions
    student_age_distribution         jsonb;
    collaborator_age_distribution    jsonb;
    student_gender_distribution      jsonb;
    collaborator_gender_distribution jsonb;
    -- Workshop & Event metrics
    workshops_count                  bigint;
    events_count                     bigint;
    avg_student_attendance_rate      numeric;
    avg_days_prospect_to_active      numeric;
    -- HQ info
    hq_name                          text;
BEGIN
    -- Get current user's role level and HQ ID
    current_role_level := public.fn_get_current_role_level();
    current_user_hq_id := public.fn_get_current_hq_id();
    -- Use single HQ ID function

    -- Permission Check:
    -- Allow if user is Konsejo Member+ (>=80) OR (Manager+ (>=50) AND target_hq_id is their HQ)
    IF current_role_level >= 80 THEN
        is_authorized := true;
    ELSIF current_role_level >= 50 AND target_hq_id = current_user_hq_id THEN
        is_authorized := true;
    END IF;

    IF NOT is_authorized THEN
        RAISE EXCEPTION 'Insufficient privileges (level % requires >= 80 or >= 50 for own HQ) to access dashboard for headquarter ID %.', current_role_level, target_hq_id;
    END IF;

    -- Fetch HQ Name
    SELECT name INTO hq_name FROM public.headquarters WHERE id = target_hq_id;
    IF NOT FOUND THEN
        RAISE EXCEPTION 'Headquarter with ID % not found.', target_hq_id;
    END IF;

    -- Calculate stats for the target headquarter (SECURITY DEFINER bypasses RLS here)

    -- Student and Collaborator Counts
    SELECT COUNT(*)
    INTO hq_active_students_count
    FROM public.students
    WHERE headquarter_id = target_hq_id
      AND status = 'active';

    SELECT COUNT(*)
    INTO hq_active_collaborators_count
    FROM public.collaborators
    WHERE headquarter_id = target_hq_id
      AND status = 'active';

    -- Student gender distribution
    SELECT jsonb_object_agg(gender, count)
    INTO student_gender_distribution
    FROM (SELECT COALESCE(gender, 'unknown') as gender, COUNT(*) as count
          FROM public.agreements a
                   JOIN public.students s ON a.user_id = s.user_id
          WHERE s.headquarter_id = target_hq_id
            AND s.status = 'active'
          GROUP BY gender) genders;

    -- Student age distribution
    SELECT jsonb_object_agg(age_group, count)
    INTO student_age_distribution
    FROM (SELECT CASE
                     WHEN age < 18 THEN '<18'
                     WHEN age BETWEEN 18 AND 24 THEN '18-24'
                     WHEN age BETWEEN 25 AND 34 THEN '25-34'
                     WHEN age BETWEEN 35 AND 44 THEN '35-44'
                     WHEN age BETWEEN 45 AND 54 THEN '45-54'
                     WHEN age >= 55 THEN '55+'
                     ELSE 'Unknown'
                     END  as age_group,
                 COUNT(*) as count
          FROM (SELECT date_part('year', age(birth_date)) as age
                FROM public.agreements a
                         JOIN public.students s ON a.user_id = s.user_id
                WHERE s.headquarter_id = target_hq_id
                  AND s.status = 'active'
                  AND birth_date IS NOT NULL) ages
          GROUP BY age_group) grouped_ages;

    -- Collaborator gender distribution
    SELECT jsonb_object_agg(gender, count)
    INTO collaborator_gender_distribution
    FROM (SELECT COALESCE(gender, 'Unknown') as gender, COUNT(*) as count
          FROM public.agreements a
                   JOIN public.collaborators c ON a.user_id = c.user_id
          WHERE c.headquarter_id = target_hq_id
            AND c.status = 'active'
          GROUP BY gender) genders;

    -- Collaborator age distribution
    SELECT jsonb_object_agg(age_group, count)
    INTO collaborator_age_distribution
    FROM (SELECT CASE
                     WHEN age < 18 THEN '<18'
                     WHEN age BETWEEN 18 AND 24 THEN '18-24'
                     WHEN age BETWEEN 25 AND 34 THEN '25-34'
                     WHEN age BETWEEN 35 AND 44 THEN '35-44'
                     WHEN age BETWEEN 45 AND 54 THEN '45-54'
                     WHEN age >= 55 THEN '55+'
                     ELSE 'Unknown'
                     END  as age_group,
                 COUNT(*) as count
          FROM (SELECT date_part('year', age(birth_date)) as age
                FROM public.agreements a
                         JOIN public.collaborators c ON a.user_id = c.user_id
                WHERE c.headquarter_id = target_hq_id
                  AND c.status = 'active'
                  AND birth_date IS NOT NULL) ages
          GROUP BY age_group) grouped_ages;

    -- Count Manager Assistants+ (role level >= 50)
    SELECT COUNT(c.*)
    INTO hq_manager_assistants_count
    FROM public.collaborators c
             JOIN public.roles r ON c.role_id = r.id
    WHERE c.headquarter_id = target_hq_id
      AND c.status = 'active'
      AND r.level >= 50;

    -- Agreement Counts
    SELECT COUNT(*)                                                                 AS total,
           COUNT(*) FILTER (WHERE status = 'prospect')                              AS prospect,
           COUNT(*) FILTER (WHERE status = 'active')                                AS active,
           COUNT(*) FILTER (WHERE status = 'inactive')                              AS inactive,
           COUNT(*) FILTER (WHERE status = 'graduated')                             AS graduated,
           COUNT(*) FILTER (WHERE created_at >= date_trunc('year', current_date))   AS this_year,
           COUNT(*) FILTER (WHERE created_at >= current_date - interval '3 months') AS last_3_months
    INTO
        hq_agreements_total,
        hq_agreements_prospect,
        hq_agreements_active,
        hq_agreements_inactive,
        hq_agreements_graduated,
        hq_agreements_this_year,
        hq_agreements_last_3_months
    FROM public.agreements
    WHERE headquarter_id = target_hq_id;

    -- Calculate average time from prospect to active status
    SELECT AVG(EXTRACT(EPOCH FROM (activation_date - created_at)) / 86400.0) -- 86400 seconds in a day
    INTO avg_days_prospect_to_active
    FROM public.agreements
    WHERE headquarter_id = target_hq_id
      AND status IN ('active', 'graduated')
      AND activation_date IS NOT NULL
      AND created_at IS NOT NULL
      AND activation_date > created_at;

    -- Workshops and Events count
    SELECT COUNT(*)
    INTO workshops_count
    FROM public.scheduled_workshops
    WHERE headquarter_id = target_hq_id
      AND season_id IN (SELECT id FROM public.seasons WHERE status = 'active');

    SELECT COUNT(*)
    INTO events_count
    FROM public.events
    WHERE headquarter_id = target_hq_id
      AND season_id IN (SELECT id FROM public.seasons WHERE status = 'active');

    -- Student attendance rate (across all workshops in active seasons)
    SELECT COALESCE(AVG(CASE WHEN attendance_status = 'present' THEN 100.0 ELSE 0.0 END), 0)
    INTO avg_student_attendance_rate
    FROM public.student_attendance sa
             JOIN public.scheduled_workshops sw ON sa.scheduled_workshop_id = sw.id
             JOIN public.students s ON sa.student_id = s.user_id
    WHERE s.headquarter_id = target_hq_id
      AND sw.season_id IN (SELECT id FROM public.seasons WHERE status = 'active');

    -- Construct JSON response
    stats := jsonb_build_object(
            'headquarter_id', target_hq_id,
            'headquarter_name', hq_name,
            'active_students_count', hq_active_students_count,
            'active_collaborators_count', hq_active_collaborators_count,
            'manager_assistants_count', hq_manager_assistants_count,
            'student_age_distribution', COALESCE(student_age_distribution, '{}'::jsonb),
            'student_gender_distribution', COALESCE(student_gender_distribution, '{}'::jsonb),
            'collaborator_age_distribution', COALESCE(collaborator_age_distribution, '{}'::jsonb),
            'collaborator_gender_distribution',
            COALESCE(collaborator_gender_distribution, '{}'::jsonb),
            'agreements_total', hq_agreements_total,
            'agreements_prospect', hq_agreements_prospect,
            'agreements_active', hq_agreements_active,
            'agreements_inactive', hq_agreements_inactive,
            'agreements_graduated', hq_agreements_graduated,
            'agreements_this_year', hq_agreements_this_year,
            'agreements_last_3_months', hq_agreements_last_3_months,
            'agreements_active_percentage', CASE
                                                WHEN hq_agreements_total > 0 THEN ROUND(
                                                        (hq_agreements_active::numeric / hq_agreements_total) *
                                                        100, 2)
                                                ELSE 0 END,
            'agreements_prospect_percentage', CASE
                                                  WHEN hq_agreements_total > 0 THEN ROUND(
                                                          (hq_agreements_prospect::numeric / hq_agreements_total) *
                                                          100, 2)
                                                  ELSE 0 END,
            'agreements_graduated_percentage', CASE
                                                   WHEN hq_agreements_total > 0 THEN ROUND(
                                                           (hq_agreements_graduated::numeric / hq_agreements_total) *
                                                           100, 2)
                                                   ELSE 0 END,
            'workshops_count', workshops_count,
            'events_count', events_count,
            'avg_student_attendance_rate', ROUND(avg_student_attendance_rate, 2),
            'avg_days_prospect_to_active', COALESCE(ROUND(avg_days_prospect_to_active, 2), 0)
             );

    RETURN stats;
END;
$$;

-- Grant execute permission (permissions checked internally)
GRANT EXECUTE ON FUNCTION get_headquarter_dashboard_stats(uuid) TO authenticated;

-- Function to get dashboard statistics for a specific user
-- Accessible by the user themselves, managers (>=50) in the same HQ, or directors (>=90)
CREATE OR REPLACE FUNCTION get_user_dashboard_stats(target_user_id uuid)
    RETURNS jsonb
    LANGUAGE plpgsql
    SECURITY DEFINER
    SET SEARCH_PATH = ''
AS
$$
DECLARE
    invoker_user_id                uuid;
    invoker_role_level             integer;
    invoker_hq_id                  uuid; -- Changed from uuid[]
    target_agreement               RECORD;
    target_role                    RECORD;
    target_hq                      RECORD;
    target_season                  RECORD;
    target_person                  RECORD; -- Can be student or collaborator details
    target_user_email              text;
    stats                          jsonb;
    target_user_type               text    := 'Unknown';
    target_record_id               uuid    := NULL;
    target_full_name               text    := NULL;
    is_authorized                  boolean := false;
    -- Student specific
    student_attendance_rate        numeric;
    student_schedule               jsonb;
    student_companion_info         jsonb;
    -- Companion specific
    companion_assigned_students    jsonb;
    companion_student_count        integer;
    -- Facilitator specific
    facilitator_workshops_count    integer;
    facilitator_upcoming_workshops jsonb;
    collaborator_details           jsonb;
BEGIN
    -- Get invoker details
    invoker_user_id := auth.uid();
    invoker_role_level := public.fn_get_current_role_level();
    invoker_hq_id := public.fn_get_current_hq_id();
    -- Use single HQ ID function

    -- Find the target user's *single latest active* agreement
    SELECT a.*
    INTO target_agreement
    FROM public.agreements a
             JOIN public.seasons s ON a.season_id = s.id
    WHERE a.user_id = target_user_id
      AND s.status = 'active'
    ORDER BY s.start_date DESC
    LIMIT 1;

    IF NOT FOUND THEN
        RAISE EXCEPTION 'No active agreement found for user ID %.', target_user_id;
    END IF;

    -- Permission Check:
    -- Allow if invoker is the target user OR invoker is Director+ (>=90) OR invoker is Manager+ (>=50) in the same HQ as the target user
    IF invoker_user_id = target_user_id THEN
        is_authorized := true;
    ELSIF invoker_role_level >= 90 THEN
        is_authorized := true;
    ELSIF invoker_role_level >= 50 AND
          target_agreement.headquarter_id = invoker_hq_id THEN -- Check against single HQ ID
        is_authorized := true;
    END IF;

    IF NOT is_authorized THEN
        RAISE EXCEPTION 'Insufficient privileges (level % requires self, >= 90, or >= 50 for same HQ) to access dashboard for user ID %.', invoker_role_level, target_user_id;
    END IF;

    -- Fetch associated records (SECURITY DEFINER bypasses RLS)
    SELECT * INTO target_hq FROM public.headquarters WHERE id = target_agreement.headquarter_id;
    SELECT * INTO target_season FROM public.seasons WHERE id = target_agreement.season_id;
    SELECT email INTO target_user_email FROM auth.users WHERE id = target_user_id;
    -- Check if the user is a student or collaborator based on the agreement/role
    SELECT * INTO target_role FROM public.roles WHERE id = target_agreement.role_id;

    -- Determine if this is a student or collaborator
    IF target_role.name = 'Student' THEN
        target_user_type := 'Student';
        -- Try to find student record
        SELECT s.id,
               s.user_id,
               s.status,
               (a.name || ' ' || a.last_name) as full_name
        INTO target_person
        FROM public.students s
                 JOIN public.agreements a ON s.user_id = a.user_id
        WHERE s.user_id = target_user_id
        LIMIT 1;
    ELSE
        target_user_type := 'Collaborator';
        -- Try to find collaborator record
        SELECT c.id,
               c.user_id,
               c.status,
               (a.name || ' ' || a.last_name) as full_name
        INTO target_person
        FROM public.collaborators c
                 JOIN public.agreements a ON c.user_id = a.user_id
        WHERE c.user_id = target_user_id
        LIMIT 1;
    END IF;

    -- Set default full name if not found
    IF target_person IS NULL THEN
        target_full_name := COALESCE(target_agreement.name || ' ' || target_agreement.last_name,
                                     'Record Not Found for Role');
    ELSE
        target_full_name := COALESCE(target_person.full_name, 'Name Not Available');
    END IF;

    -- Calculate Role-Specific Stats
    IF target_user_type = 'Student' AND target_person IS NOT NULL THEN
        -- Attendance Rate (for active season workshops)
        SELECT COALESCE(
                       ROUND(
                               (SUM(CASE WHEN sa.attendance_status = 'present' THEN 1 ELSE 0 END)::numeric /
                                NULLIF(COUNT(*), 0)) * 100,
                               2
                       ),
                       0
               )
        INTO student_attendance_rate
        FROM public.student_attendance sa
                 JOIN public.scheduled_workshops sw ON sa.scheduled_workshop_id = sw.id
        WHERE sa.student_id = target_user_id
          AND sw.season_id = target_season.id;

        -- Schedule (upcoming workshops in active season/HQ)
        WITH UpcomingWorkshops AS (SELECT sw.id             as item_id,
                                          sw.local_name     as item_name,
                                          sw.start_datetime as item_date,
                                          'workshop'        as item_type,
                                          mwt.name          as workshop_type
                                   FROM public.scheduled_workshops sw
                                            JOIN public.master_workshop_types mwt
                                                 ON sw.master_workshop_type_id = mwt.id
                                   WHERE sw.headquarter_id = target_hq.id
                                     AND sw.season_id = target_season.id
                                     AND sw.start_datetime >= current_date
                                     AND sw.status = 'scheduled'),
             UpcomingEvents AS (SELECT e.id             as item_id,
                                       e.title          as item_name,
                                       e.start_datetime as item_date,
                                       'event'          as item_type,
                                       et.name          as event_type
                                FROM public.events e
                                         JOIN public.event_types et ON e.event_type_id = et.id
                                WHERE e.headquarter_id = target_hq.id
                                  AND e.season_id = target_season.id
                                  AND e.start_datetime >= current_date
                                  AND e.status = 'scheduled'),
             CombinedSchedule AS (SELECT item_id,
                                         item_name,
                                         item_date,
                                         item_type,
                                         workshop_type as type_name
                                  FROM UpcomingWorkshops
                                  UNION ALL
                                  SELECT item_id,
                                         item_name,
                                         item_date,
                                         item_type,
                                         event_type as type_name
                                  FROM UpcomingEvents)
        SELECT COALESCE(jsonb_agg(jsonb_build_object(
                                          'item_id', cs.item_id,
                                          'item_name', cs.item_name,
                                          'item_date', cs.item_date,
                                          'item_type', cs.item_type,
                                          'type_name', cs.type_name
                                  ) ORDER BY cs.item_date ASC), '[]'::jsonb)
        INTO student_schedule
        FROM CombinedSchedule cs;

        -- Companion Info
        SELECT jsonb_build_object(
                       'companion_id', csm.companion_id,
                       'name', a.name,
                       'last_name', a.last_name,
                       'email', a.email
               )
        INTO student_companion_info
        FROM public.companion_student_map csm
                 JOIN public.agreements a ON csm.companion_id = a.user_id
        WHERE csm.student_id = target_user_id
          AND csm.season_id = target_season.id
        LIMIT 1;
        -- Assuming one companion per student per season

        -- Construct the student stats
        stats := jsonb_build_object(
                'user_id', target_user_id,
                'user_email', target_user_email,
                'user_type', target_user_type,
                'full_name', target_full_name,
                'role_name', target_role.name,
                'role_level', target_role.level,
                'headquarter_id', target_hq.id,
                'headquarter_name', target_hq.name,
                'season_id', target_season.id,
                'season_name', target_season.name,
                'season_start_date', target_season.start_date,
                'season_end_date', target_season.end_date,
                'agreement_status', target_agreement.status,
                'attendance_rate', student_attendance_rate,
                'upcoming_schedule', student_schedule,
                'companion_info', COALESCE(student_companion_info, '{}'::jsonb)
                 );

    ELSIF target_user_type = 'Collaborator' AND target_person IS NOT NULL THEN
        -- Base details for any collaborator
        collaborator_details := jsonb_build_object(
                'collaborator_id', target_user_id,
                'status', target_person.status,
                'role', target_role.name,
                'headquarter_id', target_agreement.headquarter_id,
                'headquarter_name', target_hq.name
                                );

        -- Add role-specific details for collaborators
        IF target_role.name = 'Companion' THEN
            -- Get assigned students count
            SELECT COUNT(*)
            INTO companion_student_count
            FROM public.companion_student_map
            WHERE companion_id = target_user_id
              AND season_id = target_season.id;

            -- Get assigned students details
            SELECT COALESCE(jsonb_agg(jsonb_build_object(
                    'student_id', s.user_id,
                    'name', a.name,
                    'last_name', a.last_name,
                    'status', s.status,
                    'email', a.email
                                      )), '[]'::jsonb)
            INTO companion_assigned_students
            FROM public.companion_student_map csm
                     JOIN public.students s ON csm.student_id = s.user_id
                     JOIN public.agreements a ON s.user_id = a.user_id
            WHERE csm.companion_id = target_user_id
              AND csm.season_id = target_season.id;

            -- Logic specific to Companions
            collaborator_details := collaborator_details || jsonb_build_object(
                    'assigned_students_count', companion_student_count,
                    'assigned_students', companion_assigned_students
                                                            );

        ELSIF target_role.name = 'Facilitator' THEN
            -- Count workshops
            SELECT COUNT(*)
            INTO facilitator_workshops_count
            FROM public.scheduled_workshops
            WHERE facilitator_id = target_user_id
              AND season_id = target_season.id;

            -- Get upcoming workshops
            SELECT COALESCE(jsonb_agg(jsonb_build_object(
                                              'workshop_id', sw.id,
                                              'workshop_name', sw.local_name,
                                              'start_datetime', sw.start_datetime,
                                              'end_datetime', sw.end_datetime,
                                              'workshop_type', mwt.name,
                                              'status', sw.status
                                      ) ORDER BY sw.start_datetime ASC), '[]'::jsonb)
            INTO facilitator_upcoming_workshops
            FROM public.scheduled_workshops sw
                     JOIN public.master_workshop_types mwt ON sw.master_workshop_type_id = mwt.id
            WHERE sw.facilitator_id = target_user_id
              AND sw.season_id = target_season.id
              AND sw.start_datetime >= current_date
              AND sw.status = 'scheduled';

            -- Logic specific to Facilitators
            collaborator_details := collaborator_details || jsonb_build_object(
                    'workshops_count', facilitator_workshops_count,
                    'upcoming_workshops', facilitator_upcoming_workshops
                                                            );
            -- Add other ELSIF branches for other specific collaborator roles if needed
        END IF;
        -- End specific collaborator role checks

        -- Add the collaborator-specific details to the main stats object
        stats := jsonb_build_object(
                'user_id', target_user_id,
                'user_email', target_user_email,
                'user_type', target_user_type,
                'full_name', target_full_name,
                'role_name', target_role.name,
                'role_level', target_role.level,
                'headquarter_id', target_hq.id,
                'headquarter_name', target_hq.name,
                'season_id', target_season.id,
                'season_name', target_season.name,
                'season_start_date', target_season.start_date,
                'season_end_date', target_season.end_date,
                'agreement_status', target_agreement.status,
                'collaborator_details', collaborator_details
                 );
    ELSE
        -- Basic info if specific role details not available
        stats := jsonb_build_object(
                'user_id', target_user_id,
                'user_email', target_user_email,
                'user_type', target_user_type,
                'full_name', target_full_name,
                'role_name', COALESCE(target_role.name, 'Unknown'),
                'role_level', COALESCE(target_role.level, 0),
                'headquarter_id', target_hq.id,
                'headquarter_name', target_hq.name,
                'season_id', target_season.id,
                'season_name', target_season.name,
                'agreement_status', target_agreement.status
                 );
    END IF;

    RETURN stats;
END;
$$;

-- Grant execute permission
GRANT EXECUTE ON FUNCTION get_user_dashboard_stats(uuid) TO authenticated;

-- Function for Companions: Get assigned students who missed workshops
CREATE OR REPLACE FUNCTION get_companion_student_attendance_issues(last_n_items integer DEFAULT 5)
    RETURNS TABLE
            (
                student_id             uuid,
                student_first_name     text,
                student_last_name      text,
                missed_workshops_count bigint,
                total_workshops_count  bigint,
                attendance_percentage  numeric
            )
    LANGUAGE plpgsql
    SECURITY INVOKER -- Run as the caller, RLS on underlying tables will apply implicitly
    SET search_path = ''
AS
$$
DECLARE
    caller_id    uuid    := auth.uid();
    is_companion boolean := false;
BEGIN
    -- Verify the caller is currently mapped as a companion to at least one student
    SELECT EXISTS (SELECT 1 FROM public.companion_student_map WHERE companion_id = caller_id)
    INTO is_companion;

    IF NOT is_companion THEN
        RAISE EXCEPTION 'User % is not currently assigned as a companion.', caller_id;
    END IF;

    RETURN QUERY
        WITH AssignedStudents AS (
            -- Get students assigned to the calling companion
            SELECT csm.student_id
            FROM public.companion_student_map csm
            WHERE csm.companion_id = caller_id),
             StudentWorkshopAttendance AS (
                 -- Get attendance records for workshops
                 SELECT s.user_id                                       as student_id,
                        s.headquarter_id,
                        a.name                                          as student_first_name,
                        a.last_name                                     as student_last_name,
                        COUNT(sa.id)                                    as total_workshops,
                        COUNT(sa.id)
                        FILTER (WHERE sa.attendance_status = 'present') as attended_workshops
                 FROM public.students s
                          JOIN AssignedStudents ast ON s.user_id = ast.student_id
                          JOIN public.agreements a ON s.user_id = a.user_id
                          LEFT JOIN public.student_attendance sa ON s.user_id = sa.student_id
                 GROUP BY s.user_id, s.headquarter_id, a.name, a.last_name)
        -- Final selection: Students with attendance issues
        SELECT swa.student_id,
               swa.student_first_name,
               swa.student_last_name,
               (swa.total_workshops - swa.attended_workshops) as missed_workshops_count,
               swa.total_workshops                            as total_workshops_count,
               CASE
                   WHEN swa.total_workshops > 0 THEN
                       ROUND((swa.attended_workshops::numeric / swa.total_workshops) * 100, 2)
                   ELSE 0
                   END                                        as attendance_percentage
        FROM StudentWorkshopAttendance swa
        WHERE swa.total_workshops > 0
        ORDER BY attendance_percentage ASC;
END;
$$;

-- Grant execute permission
GRANT EXECUTE ON FUNCTION get_companion_student_attendance_issues(integer) TO authenticated;

-- Function for Directors: Rank HQs by agreements created this year
CREATE OR REPLACE FUNCTION get_hq_agreement_ranking_this_year()
    RETURNS TABLE
            (
                headquarter_id             uuid,
                headquarter_name           text,
                agreements_this_year_count bigint,
                agreements_graduated_count bigint,
                graduation_percentage      numeric
            )
    LANGUAGE plpgsql
    SECURITY DEFINER -- Needs to see all agreements to rank HQs
    SET search_path = ''
AS
$$
DECLARE
    current_role_level integer;
BEGIN
    -- Permission Check
    current_role_level := public.fn_get_current_role_level();
    IF current_role_level < 80 THEN -- Let's use Director level 80
        RAISE EXCEPTION 'Insufficient privileges. Required level: 80, Your level: %', current_role_level;
    END IF;

    -- Calculate and return ranking
    RETURN QUERY
        SELECT h.id,
               h.name,
               COUNT(a.id)                                       as agreements_count,
               COUNT(a.id) FILTER (WHERE a.status = 'graduated') as graduated_count,
               CASE
                   WHEN COUNT(a.id) > 0 THEN
                       ROUND((COUNT(a.id) FILTER (WHERE a.status = 'graduated')::numeric /
                              COUNT(a.id)) * 100, 2)
                   ELSE 0
                   END                                           as graduation_percentage
        FROM public.agreements a
                 JOIN public.headquarters h ON a.headquarter_id = h.id
        WHERE a.created_at >= date_trunc('year', current_date)
        GROUP BY h.id, h.name
        ORDER BY agreements_count DESC;
END;
$$;

-- Grant execute permission
GRANT EXECUTE ON FUNCTION get_hq_agreement_ranking_this_year() TO authenticated;

-- Function for Managers/Directors: Get a breakdown of agreements by user role and status for a specific HQ
CREATE OR REPLACE FUNCTION get_hq_agreement_breakdown(target_hq_id uuid)
    RETURNS jsonb
    LANGUAGE plpgsql
    SECURITY DEFINER -- Needs to query across users/roles potentially outside caller's direct view
    SET search_path = ''
AS
$$
DECLARE
    current_role_level integer;
    current_user_hq_id uuid;
    breakdown_data     jsonb;
BEGIN
    -- Get the role level and HQ ID of the user calling the function
    SELECT public.fn_get_current_role_level(),
           public.fn_get_current_hq_id() -- Use single HQ ID function
    INTO current_role_level, current_user_hq_id;

    -- Permission Check: Allow if user is in the target HQ or role level is >= 70
    IF NOT (current_user_hq_id = target_hq_id OR current_role_level >= 70) THEN
        RAISE EXCEPTION 'Insufficient privileges. User must belong to the target headquarter (%) or have role level >= 70.', target_hq_id;
    END IF;

    -- Calculate the breakdown
    SELECT COALESCE(jsonb_agg(row_to_json(t)), '[]'::jsonb)
    INTO breakdown_data
    FROM (SELECT r.name   AS role_name,
                 a.status AS agreement_status,
                 COUNT(*) AS count
          FROM public.agreements a
                   JOIN public.roles r ON a.role_id = r.id -- Join directly to roles via a.role_id
          WHERE a.headquarter_id = target_hq_id
          GROUP BY r.name, a.status
          ORDER BY r.name, a.status) t;

    RETURN breakdown_data;
END;
$$;

-- Grant execute permission
GRANT EXECUTE ON FUNCTION get_hq_agreement_breakdown(uuid) TO authenticated;

-- Function for Directors: Get a global breakdown of agreements by user role and status
CREATE OR REPLACE FUNCTION get_global_agreement_breakdown()
    RETURNS jsonb
    LANGUAGE plpgsql
    SECURITY DEFINER -- Needs to query across users/roles globally
    SET search_path = ''
AS
$$
DECLARE
    current_role_level integer;
    breakdown_data     jsonb;
BEGIN
    -- Permission Check
    current_role_level := public.fn_get_current_role_level();
    IF current_role_level < 90 THEN -- Require Director level 90
        RAISE EXCEPTION 'Insufficient privileges. Required level: 90, Your level: %', current_role_level;
    END IF;

    -- Calculate the global breakdown
    SELECT COALESCE(jsonb_agg(row_to_json(t)), '[]'::jsonb)
    INTO breakdown_data
    FROM (SELECT r.name   AS role_name,
                 a.status AS agreement_status,
                 COUNT(*) AS count
          FROM public.agreements a
                   JOIN public.roles r ON a.role_id = r.id -- Join directly to roles via a.role_id
          -- No headquarter filter for global view
          GROUP BY r.name, a.status
          ORDER BY r.name, a.status) t;

    RETURN breakdown_data;
END;
$$;

-- Grant execute permission
GRANT EXECUTE ON FUNCTION get_global_agreement_breakdown() TO authenticated;

-- Function to calculate average time from prospect to active status
CREATE OR REPLACE FUNCTION get_prospect_to_active_avg_time(target_hq_id uuid DEFAULT NULL)
    RETURNS jsonb
    LANGUAGE plpgsql
    SECURITY DEFINER
    SET search_path = ''
AS
$$
DECLARE
    current_role_level integer;
    current_user_hq_id uuid;
    is_authorized      boolean := false;
    result_data        jsonb;
    avg_days_global    numeric;
    avg_days_by_hq     jsonb;
BEGIN
    -- Get current user's role level and HQ ID
    current_role_level := public.fn_get_current_role_level();
    current_user_hq_id := public.fn_get_current_hq_id();

    -- Permission Check:
    -- If target_hq_id is NULL (global view), require Director+ (>=80)
    -- If target_hq_id is specified, allow if user is in that HQ or role level is >= 70
    IF target_hq_id IS NULL THEN
        IF current_role_level >= 80 THEN
            is_authorized := true;
        END IF;
    ELSE
        IF current_role_level >= 80 OR
           (current_role_level >= 50 AND target_hq_id = current_user_hq_id) THEN
            is_authorized := true;
        END IF;
    END IF;

    IF NOT is_authorized THEN
        RAISE EXCEPTION 'Insufficient privileges to access prospect-to-active conversion time statistics.';
    END IF;

    -- Calculate global average (if no specific HQ requested)
    IF target_hq_id IS NULL THEN
        SELECT ROUND(AVG(EXTRACT(EPOCH FROM (activation_date - created_at)) / 86400.0),
                     2) -- Convert to days
        INTO avg_days_global
        FROM public.agreements
        WHERE status IN ('active', 'graduated')
          AND activation_date IS NOT NULL
          AND created_at IS NOT NULL
          AND activation_date > created_at;

        -- Calculate average by headquarter
        SELECT jsonb_object_agg(hq_name, avg_days)
        INTO avg_days_by_hq
        FROM (SELECT h.name   as hq_name,
                     ROUND(AVG(EXTRACT(EPOCH FROM (a.activation_date - a.created_at)) / 86400.0),
                           2) as avg_days
              FROM public.agreements a
                       JOIN public.headquarters h ON a.headquarter_id = h.id
              WHERE a.status IN ('active', 'graduated')
                AND a.activation_date IS NOT NULL
                AND a.created_at IS NOT NULL
                AND a.activation_date > a.created_at
              GROUP BY h.name
              ORDER BY avg_days) t;

        -- Build result
        result_data := jsonb_build_object(
                'global_avg_days', COALESCE(avg_days_global, 0),
                'by_headquarter', COALESCE(avg_days_by_hq, '{}'::jsonb)
                       );
    ELSE
        -- Calculate for specific headquarter
        SELECT ROUND(AVG(EXTRACT(EPOCH FROM (activation_date - created_at)) / 86400.0),
                     2) -- Convert to days
        INTO avg_days_global
        FROM public.agreements
        WHERE headquarter_id = target_hq_id
          AND status IN ('active', 'graduated')
          AND activation_date IS NOT NULL
          AND created_at IS NOT NULL
          AND activation_date > created_at;

        -- Get headquarter name
        SELECT jsonb_build_object(
                       'headquarter_id', target_hq_id,
                       'headquarter_name', h.name,
                       'avg_days', COALESCE(avg_days_global, 0)
               )
        INTO result_data
        FROM public.headquarters h
        WHERE h.id = target_hq_id;
    END IF;

    RETURN result_data;
END;
$$;

-- Grant execute permission
GRANT EXECUTE ON FUNCTION get_prospect_to_active_avg_time(uuid) TO authenticated;

-- Function to get trend of active students per quarter for each headquarter
CREATE OR REPLACE FUNCTION get_student_trend_by_quarter(quarters_back integer DEFAULT 4)
    RETURNS jsonb
    LANGUAGE plpgsql
    SECURITY DEFINER
    SET SEARCH_PATH = ''
AS
$$
DECLARE
    current_role_level integer;
    result_data        jsonb;
    quarters           jsonb;
BEGIN
    -- Permission Check
    current_role_level := public.fn_get_current_role_level();
    IF current_role_level < 80 THEN
        RAISE EXCEPTION 'Insufficient privileges. Required level: 80, Your level: %', current_role_level;
    END IF;

    -- Generate array of quarters to analyze
    WITH RECURSIVE quarters_cte AS (SELECT date_trunc('quarter', current_date) as quarter_start,
                                           1                                   as quarter_num
                                    UNION ALL
                                    SELECT date_trunc('quarter', quarter_start - interval '3 months') as quarter_start,
                                           quarter_num + 1
                                    FROM quarters_cte
                                    WHERE quarter_num < quarters_back)
    SELECT jsonb_agg(
                   jsonb_build_object(
                           'quarter', to_char(quarter_start, 'YYYY-"Q"Q'),
                           'start_date', quarter_start,
                           'end_date', quarter_start + interval '3 months' - interval '1 day'
                   )
                   ORDER BY quarter_start DESC
           )
    INTO quarters
    FROM quarters_cte;

    -- Calculate active students per quarter per headquarter
    WITH quarter_dates AS (SELECT q ->> 'quarter'                   as quarter_label,
                                  (q ->> 'start_date')::timestamptz as start_date,
                                  (q ->> 'end_date')::timestamptz   as end_date
                           FROM jsonb_array_elements(quarters) as q),
         headquarter_quarters AS (SELECT h.id   as hq_id,
                                         h.name as hq_name,
                                         qd.quarter_label,
                                         qd.start_date,
                                         qd.end_date,
                                         COUNT(DISTINCT s.user_id) FILTER (
                                             WHERE s.status = 'active'
                                                 AND (s.enrollment_date <= qd.end_date)
                                             -- Additional filtering if needed
                                             )  as active_students
                                  FROM public.headquarters h
                                           CROSS JOIN quarter_dates qd
                                           LEFT JOIN public.students s ON s.headquarter_id = h.id
                                  GROUP BY h.id, h.name, qd.quarter_label, qd.start_date,
                                           qd.end_date
                                  ORDER BY h.name, qd.start_date DESC),
         headquarter_trends AS (SELECT hq_id,
                                       hq_name,
                                       jsonb_agg(
                                               jsonb_build_object(
                                                       'quarter', quarter_label,
                                                       'active_students', active_students
                                               )
                                               ORDER BY start_date DESC
                                       ) as quarters_data
                                FROM headquarter_quarters
                                GROUP BY hq_id, hq_name)
    SELECT jsonb_agg(
                   jsonb_build_object(
                           'headquarter_id', hq_id,
                           'headquarter_name', hq_name,
                           'quarters', quarters_data
                   )
           )
    INTO result_data
    FROM headquarter_trends;

    RETURN jsonb_build_object(
            'quarters_analyzed', quarters,
            'headquarter_trends', COALESCE(result_data, '[]'::jsonb)
           );
END;
$$;

-- Grant execute permission
GRANT EXECUTE ON FUNCTION get_student_trend_by_quarter(integer) TO authenticated;

-- Function to identify headquarters with the best student-graduation ratio
CREATE OR REPLACE FUNCTION get_hq_graduation_ranking(months_back integer DEFAULT 12)
    RETURNS jsonb
    LANGUAGE plpgsql
    SET search_path = ''
    SECURITY DEFINER
AS
$$
DECLARE
    current_role_level integer;
    result_data        jsonb;
BEGIN
    -- Permission Check
    current_role_level := public.fn_get_current_role_level();
    IF current_role_level < 80 THEN
        RAISE EXCEPTION 'Insufficient privileges. Required level: 80, Your level: %', current_role_level;
    END IF;

    -- Calculate graduation ratio for each headquarter
    WITH hq_stats AS (SELECT h.id   as hq_id,
                             h.name as hq_name,
                             COUNT(DISTINCT a.id) FILTER (
                                 WHERE
                                 a.role_id = (SELECT id FROM public.roles WHERE name = 'Student')
                                     AND a.created_at >= current_date - (months_back || ' months')::interval
                                 )  as total_students,
                             COUNT(DISTINCT a.id) FILTER (
                                 WHERE
                                 a.role_id = (SELECT id FROM public.roles WHERE name = 'Student')
                                     AND a.status = 'graduated'
                                     AND a.created_at >= current_date - (months_back || ' months')::interval
                                 )  as graduated_students
                      FROM public.headquarters h
                               LEFT JOIN public.agreements a ON a.headquarter_id = h.id
                      GROUP BY h.id, h.name)
    SELECT jsonb_agg(
                   jsonb_build_object(
                           'headquarter_id', hq_id,
                           'headquarter_name', hq_name,
                           'total_students', total_students,
                           'graduated_students', graduated_students,
                           'graduation_ratio', CASE
                                                   WHEN total_students > 0 THEN
                                                       ROUND(
                                                               (graduated_students::numeric / total_students) *
                                                               100, 2)
                                                   ELSE 0
                               END
                   )
                   ORDER BY
                       CASE
                           WHEN total_students > 0 THEN
                               (graduated_students::numeric / total_students)
                           ELSE 0 END DESC
           )
    INTO result_data
    FROM hq_stats
    WHERE total_students > 0;

    RETURN jsonb_build_object(
            'months_analyzed', months_back,
            'headquarter_ranking', COALESCE(result_data, '[]'::jsonb)
           );
END;
$$;

-- Grant execute permission
GRANT EXECUTE ON FUNCTION get_hq_graduation_ranking(integer) TO authenticated;

-- Function to calculate the proportion of facilitators holding multiple roles
CREATE OR REPLACE FUNCTION get_facilitator_multiple_roles_stats()
    RETURNS jsonb
    LANGUAGE plpgsql
    SECURITY DEFINER
    SET search_path = ''
AS
$$
DECLARE
    current_role_level integer;
    result_data        jsonb;
    global_stats       jsonb;
    hq_stats           jsonb;
BEGIN
    -- Permission Check
    current_role_level := public.fn_get_current_role_level();
    IF current_role_level < 80 THEN
        RAISE EXCEPTION 'Insufficient privileges. Required level: 80, Your level: %', current_role_level;
    END IF;

    -- Calculate global statistics
    WITH facilitator_roles AS (SELECT a.user_id,
                                      COUNT(DISTINCT a.headquarter_id) as hq_count,
                                      COUNT(DISTINCT a.role_id)        as role_count
                               FROM public.agreements a
                                        JOIN public.roles r ON a.role_id = r.id
                               WHERE r.name = 'Facilitator'
                                 AND a.status = 'active'
                               GROUP BY a.user_id)
    SELECT jsonb_build_object(
                   'total_facilitators', COUNT(*),
                   'facilitators_multiple_hqs', COUNT(*) FILTER (WHERE hq_count > 1),
                   'facilitators_multiple_roles', COUNT(*) FILTER (WHERE role_count > 1),
                   'multiple_hqs_percentage', ROUND(
                           (COUNT(*) FILTER (WHERE hq_count > 1)::numeric / NULLIF(COUNT(*), 0)) *
                           100, 2),
                   'multiple_roles_percentage', ROUND(
                           (COUNT(*) FILTER (WHERE role_count > 1)::numeric / NULLIF(COUNT(*), 0)) *
                           100, 2)
           )
    INTO global_stats
    FROM facilitator_roles;

    -- Calculate statistics by headquarter
    WITH facilitator_hq_roles AS (SELECT a.headquarter_id,
                                         a.user_id,
                                         COUNT(DISTINCT a.role_id) as role_count
                                  FROM public.agreements a
                                           JOIN public.roles r ON a.role_id = r.id
                                  WHERE r.name = 'Facilitator'
                                    AND a.status = 'active'
                                  GROUP BY a.headquarter_id, a.user_id),
         hq_role_stats AS (SELECT h.id                              as hq_id,
                                  h.name                            as hq_name,
                                  COUNT(DISTINCT fhr.user_id)       as total_facilitators,
                                  COUNT(DISTINCT fhr.user_id)
                                  FILTER (WHERE fhr.role_count > 1) as facilitators_multiple_roles
                           FROM public.headquarters h
                                    LEFT JOIN facilitator_hq_roles fhr ON h.id = fhr.headquarter_id
                           GROUP BY h.id, h.name)
    SELECT jsonb_agg(
                   jsonb_build_object(
                           'headquarter_id', hq_id,
                           'headquarter_name', hq_name,
                           'total_facilitators', total_facilitators,
                           'facilitators_multiple_roles', facilitators_multiple_roles,
                           'multiple_roles_percentage', CASE
                                                            WHEN total_facilitators > 0 THEN
                                                                ROUND(
                                                                        (facilitators_multiple_roles::numeric / total_facilitators) *
                                                                        100, 2)
                                                            ELSE 0
                               END
                   )
                   ORDER BY
                       CASE
                           WHEN total_facilitators > 0 THEN
                               (facilitators_multiple_roles::numeric / total_facilitators)
                           ELSE 0 END DESC
           )
    INTO hq_stats
    FROM hq_role_stats;

    -- Combine results
    result_data := jsonb_build_object(
            'global', COALESCE(global_stats, '{}'::jsonb),
            'by_headquarter', COALESCE(hq_stats, '[]'::jsonb)
                   );

    RETURN result_data;
END;
$$;

-- Grant execute permission
GRANT EXECUTE ON FUNCTION get_facilitator_multiple_roles_stats() TO authenticated;

-- -- NEW FUNCTION: Get workshop attendance statistics by headquarter
-- CREATE OR REPLACE FUNCTION get_workshop_attendance_stats(target_hq_id uuid DEFAULT NULL, season_id uuid DEFAULT NULL)
--     RETURNS jsonb
--     LANGUAGE plpgsql
--     SECURITY DEFINER
--     SET SEARCH_PATH = ''
-- AS
-- $$
-- DECLARE
--     current_role_level  integer;
--     current_user_hq_id  uuid;
--     is_authorized       boolean := false;
--     result_data         jsonb;
--     workshop_attendance jsonb;
--     workshop_types      jsonb;
-- BEGIN
--     -- Get current user's role level and HQ ID
--     current_role_level := public.fn_get_current_role_level();
--     current_user_hq_id := public.fn_get_current_hq_id();
--
--     -- Permission Check
--     IF target_hq_id IS NULL THEN
--         -- Global stats require level 80+
--         IF current_role_level >= 80 THEN
--             is_authorized := true;
--         END IF;
--     ELSE
--         -- HQ-specific stats require level 80+ OR level 50+ and in the same HQ
--         IF current_role_level >= 80 OR
--            (current_role_level >= 50 AND target_hq_id = current_user_hq_id) THEN
--             is_authorized := true;
--         END IF;
--     END IF;
--
--     IF NOT is_authorized THEN
--         RAISE EXCEPTION 'Insufficient privileges to access workshop attendance statistics.';
--     END IF;
--
--     -- Default to current active season if none specified
--     IF season_id IS NULL THEN
--         SELECT id
--         INTO season_id
--         FROM public.seasons
--         WHERE status = 'active'
--         ORDER BY start_date DESC
--         LIMIT 1;
--     END IF;
--
--     -- Calculate workshop attendance statistics
--     IF target_hq_id IS NULL THEN
--         -- Global stats across all headquarters
--
--         -- By workshop type
--         SELECT jsonb_agg(
--                        jsonb_build_object(
--                                'workshop_type', mwt.name,
--                                'total_workshops', COUNT(DISTINCT sw.id),
--                                'total_attendances', COUNT(sa.id),
--                                'present_count',
--                                COUNT(sa.id) FILTER (WHERE sa.attendance_status = 'present'),
--                                'absent_count',
--                                COUNT(sa.id) FILTER (WHERE sa.attendance_status = 'absent'),
--                                'attendance_rate', CASE
--                                                       WHEN COUNT(sa.id) > 0 THEN
--                                                           ROUND((COUNT(sa.id)
--                                                                  FILTER (WHERE sa.attendance_status = 'present')::numeric /
--                                                                  COUNT(sa.id)) * 100, 2)
--                                                       ELSE 0
--                                    END
--                        )
--                        ORDER BY COUNT(DISTINCT sw.id) DESC
--                )
--         INTO workshop_types
--         FROM public.scheduled_workshops sw
--                  JOIN public.master_workshop_types mwt ON sw.master_workshop_type_id = mwt.id
--                  LEFT JOIN public.student_attendance sa ON sw.id = sa.scheduled_workshop_id
--         WHERE sw.season_id = season_id
--         GROUP BY mwt.name;
--
--         -- By headquarter
--         SELECT jsonb_agg(
--                        jsonb_build_object(
--                                'headquarter_id', h.id,
--                                'headquarter_name', h.name,
--                                'total_workshops', COUNT(DISTINCT sw.id),
--                                'total_attendances', COUNT(sa.id),
--                                'present_count',
--                                COUNT(sa.id) FILTER (WHERE sa.attendance_status = 'present'),
--                                'absent_count',
--                                COUNT(sa.id) FILTER (WHERE sa.attendance_status = 'absent'),
--                                'attendance_rate', CASE
--                                                       WHEN COUNT(sa.id) > 0 THEN
--                                                           ROUND((COUNT(sa.id)
--                                                                  FILTER (WHERE sa.attendance_status = 'present')::numeric /
--                                                                  COUNT(sa.id)) * 100, 2)
--                                                       ELSE 0
--                                    END
--                        )
--                        ORDER BY
--                            CASE
--                                WHEN COUNT(sa.id) > 0 THEN
--                                    (COUNT(sa.id)
--                                     FILTER (WHERE sa.attendance_status = 'present')::numeric /
--                                     COUNT(sa.id))
--                                ELSE 0 END DESC
--                )
--         INTO workshop_attendance
--         FROM public.scheduled_workshops sw
--                  JOIN public.headquarters h ON sw.headquarter_id = h.id
--                  LEFT JOIN public.student_attendance sa ON sw.id = sa.scheduled_workshop_id
--         WHERE sw.season_id = season_id
--         GROUP BY h.id, h.name;
--
--         -- Build result
--         result_data := jsonb_build_object(
--                 'season_id', season_id,
--                 'by_workshop_type', COALESCE(workshop_types, '[]'::jsonb),
--                 'by_headquarter', COALESCE(workshop_attendance, '[]'::jsonb)
--                        );
--     ELSE
--         -- HQ-specific stats
--
--         -- By workshop type for specific HQ
--         SELECT jsonb_agg(
--                        jsonb_build_object(
--                                'workshop_type', mwt.name,
--                                'total_workshops', COUNT(DISTINCT sw.id),
--                                'total_attendances', COUNT(sa.id),
--                                'present_count',
--                                COUNT(sa.id) FILTER (WHERE sa.attendance_status = 'present'),
--                                'absent_count',
--                                COUNT(sa.id) FILTER (WHERE sa.attendance_status = 'absent'),
--                                'attendance_rate', CASE
--                                                       WHEN COUNT(sa.id) > 0 THEN
--                                                           ROUND((COUNT(sa.id)
--                                                                  FILTER (WHERE sa.attendance_status = 'present')::numeric /
--                                                                  COUNT(sa.id)) * 100, 2)
--                                                       ELSE 0
--                                    END
--                        )
--                        ORDER BY COUNT(DISTINCT sw.id) DESC
--                )
--         INTO workshop_types
--         FROM public.scheduled_workshops sw
--                  JOIN public.master_workshop_types mwt ON sw.master_workshop_type_id = mwt.id
--                  LEFT JOIN public.student_attendance sa ON sw.id = sa.scheduled_workshop_id
--         WHERE sw.season_id = season_id
--           AND sw.headquarter_id = target_hq_id
--         GROUP BY mwt.name;
--
--         -- Get headquarter name
--         SELECT jsonb_build_object(
--                        'headquarter_id', h.id,
--                        'headquarter_name', h.name,
--                        'season_id', season_id,
--                        'total_workshops', COUNT(DISTINCT sw.id),
--                        'total_attendances', COUNT(sa.id),
--                        'present_count',
--                        COUNT(sa.id) FILTER (WHERE sa.attendance_status = 'present'),
--                        'absent_count', COUNT(sa.id) FILTER (WHERE sa.attendance_status = 'absent'),
--                        'attendance_rate', CASE
--                                               WHEN COUNT(sa.id) > 0 THEN
--                                                   ROUND((COUNT(sa.id)
--                                                          FILTER (WHERE sa.attendance_status = 'present')::numeric /
--                                                          COUNT(sa.id)) * 100, 2)
--                                               ELSE 0
--                            END,
--                        'by_workshop_type', COALESCE(workshop_types, '[]'::jsonb)
--                )
--         INTO result_data
--         FROM public.headquarters h
--                  LEFT JOIN public.scheduled_workshops sw
--                            ON h.id = sw.headquarter_id AND sw.season_id = season_id
--                  LEFT JOIN public.student_attendance sa ON sw.id = sa.scheduled_workshop_id
--         WHERE h.id = target_hq_id
--         GROUP BY h.id, h.name;
--     END IF;
--
--     RETURN result_data;
-- END;
-- $$;
--
-- -- Grant execute permission
-- GRANT EXECUTE ON FUNCTION get_workshop_attendance_stats(uuid, uuid) TO authenticated;

-- NEW FUNCTION: Get student progress statistics
CREATE OR REPLACE FUNCTION get_student_progress_stats(target_hq_id uuid DEFAULT NULL)
    RETURNS jsonb
    LANGUAGE plpgsql
    SECURITY DEFINER
    SET SEARCH_PATH = ''
AS
$$
DECLARE
    current_role_level integer;
    current_user_hq_id uuid;
    is_authorized      boolean := false;
    result_data        jsonb;
BEGIN
    -- Get current user's role level and HQ ID
    current_role_level := public.fn_get_current_role_level();
    current_user_hq_id := public.fn_get_current_hq_id();

    -- Permission Check
    IF target_hq_id IS NULL THEN
        -- Global stats require level 80+
        IF current_role_level >= 80 THEN
            is_authorized := true;
        END IF;
    ELSE
        -- HQ-specific stats require level 80+ OR level 50+ and in the same HQ
        IF current_role_level >= 80 OR
           (current_role_level >= 50 AND target_hq_id = current_user_hq_id) THEN
            is_authorized := true;
        END IF;
    END IF;

    IF NOT is_authorized THEN
        RAISE EXCEPTION 'Insufficient privileges to access student progress statistics.';
    END IF;

    -- Calculate student progress statistics
    IF target_hq_id IS NULL THEN
        -- Global student progress stats
        WITH student_status_counts AS (SELECT h.id                                              as hq_id,
                                              h.name                                            as hq_name,
                                              COUNT(s.id) FILTER (WHERE s.status = 'active')    as active_count,
                                              COUNT(s.id) FILTER (WHERE s.status = 'prospect')  as prospect_count,
                                              COUNT(s.id) FILTER (WHERE s.status = 'graduated') as graduated_count,
                                              COUNT(s.id) FILTER (WHERE s.status = 'inactive')  as inactive_count,
                                              COUNT(s.id)                                       as total_count
                                       FROM public.headquarters h
                                                LEFT JOIN public.students s ON h.id = s.headquarter_id
                                       GROUP BY h.id, h.name),
             attendance_stats AS (SELECT s.headquarter_id,
                                         AVG(CASE
                                                 WHEN sa.attendance_status = 'present' THEN 100.0
                                                 ELSE 0.0 END) as avg_attendance_rate
                                  FROM public.student_attendance sa
                                           JOIN public.students s ON sa.student_id = s.user_id
                                  GROUP BY s.headquarter_id)
        SELECT jsonb_agg(
                       jsonb_build_object(
                               'headquarter_id', ssc.hq_id,
                               'headquarter_name', ssc.hq_name,
                               'active_count', ssc.active_count,
                               'prospect_count', ssc.prospect_count,
                               'graduated_count', ssc.graduated_count,
                               'inactive_count', ssc.inactive_count,
                               'total_count', ssc.total_count,
                               'active_percentage', CASE
                                                        WHEN ssc.total_count > 0 THEN
                                                            ROUND(
                                                                    (ssc.active_count::numeric / ssc.total_count) *
                                                                    100, 2)
                                                        ELSE 0
                                   END,
                               'graduated_percentage', CASE
                                                           WHEN ssc.total_count > 0 THEN
                                                               ROUND(
                                                                       (ssc.graduated_count::numeric / ssc.total_count) *
                                                                       100, 2)
                                                           ELSE 0
                                   END,
                               'avg_attendance_rate', ROUND(COALESCE(ast.avg_attendance_rate, 0), 2)
                       )
                       ORDER BY ssc.total_count DESC
               )
        INTO result_data
        FROM student_status_counts ssc
                 LEFT JOIN attendance_stats ast ON ssc.hq_id = ast.headquarter_id;
    ELSE
        -- HQ-specific student progress stats
        WITH student_data AS (SELECT COUNT(s.id) FILTER (WHERE s.status = 'active')    as active_count,
                                     COUNT(s.id) FILTER (WHERE s.status = 'prospect')  as prospect_count,
                                     COUNT(s.id) FILTER (WHERE s.status = 'graduated') as graduated_count,
                                     COUNT(s.id) FILTER (WHERE s.status = 'inactive')  as inactive_count,
                                     COUNT(s.id)                                       as total_count,
                                     AVG(CASE
                                             WHEN sa.attendance_status = 'present' THEN 100.0
                                             ELSE 0.0 END)                             as avg_attendance_rate
                              FROM public.headquarters h
                                       LEFT JOIN public.students s ON h.id = s.headquarter_id
                                       LEFT JOIN public.student_attendance sa ON s.user_id = sa.student_id
                              WHERE h.id = target_hq_id
                              GROUP BY h.id)
        SELECT jsonb_build_object(
                       'headquarter_id', target_hq_id,
                       'headquarter_name', h.name,
                       'active_count', COALESCE(sd.active_count, 0),
                       'prospect_count', COALESCE(sd.prospect_count, 0),
                       'graduated_count', COALESCE(sd.graduated_count, 0),
                       'inactive_count', COALESCE(sd.inactive_count, 0),
                       'total_count', COALESCE(sd.total_count, 0),
                       'active_percentage', CASE
                                                WHEN COALESCE(sd.total_count, 0) > 0 THEN
                                                    ROUND(
                                                            (sd.active_count::numeric / sd.total_count) *
                                                            100, 2)
                                                ELSE 0
                           END,
                       'graduated_percentage', CASE
                                                   WHEN COALESCE(sd.total_count, 0) > 0 THEN
                                                       ROUND(
                                                               (sd.graduated_count::numeric / sd.total_count) *
                                                               100, 2)
                                                   ELSE 0
                           END,
                       'avg_attendance_rate', ROUND(COALESCE(sd.avg_attendance_rate, 0), 2)
               )
        INTO result_data
        FROM public.headquarters h
                 LEFT JOIN student_data sd ON TRUE
        WHERE h.id = target_hq_id;
    END IF;

    RETURN result_data;
END;
$$;

-- Grant execute permission
GRANT EXECUTE ON FUNCTION get_student_progress_stats(uuid) TO authenticated;

-- NEW FUNCTION: Get companion effectiveness metrics
CREATE OR REPLACE FUNCTION get_companion_effectiveness_metrics(target_hq_id uuid DEFAULT NULL)
    RETURNS jsonb
    LANGUAGE plpgsql
    SECURITY DEFINER
    SET search_path = ''
AS
$$
DECLARE
    current_role_level integer;
    current_user_hq_id uuid;
    is_authorized      boolean := false;
    result_data        jsonb;
BEGIN
    -- Get current user's role level and HQ ID
    current_role_level := public.fn_get_current_role_level();
    current_user_hq_id := public.fn_get_current_hq_id();

    -- Permission Check
    IF target_hq_id IS NULL THEN
        -- Global stats require level 80+
        IF current_role_level >= 80 THEN
            is_authorized := true;
        END IF;
    ELSE
        -- HQ-specific stats require level 80+ OR level 50+ and in the same HQ
        IF current_role_level >= 80 OR
           (current_role_level >= 50 AND target_hq_id = current_user_hq_id) THEN
            is_authorized := true;
        END IF;
    END IF;

    IF NOT is_authorized THEN
        RAISE EXCEPTION 'Insufficient privileges to access companion effectiveness metrics.';
    END IF;

    -- Calculate companion effectiveness metrics
    IF target_hq_id IS NULL THEN
        -- Global companion metrics
        WITH companion_metrics AS (SELECT csm.headquarter_id,
                                          csm.companion_id,
                                          COUNT(DISTINCT csm.student_id) as assigned_students,
                                          AVG(CASE
                                                  WHEN sa.attendance_status = 'present' THEN 100.0
                                                  ELSE 0.0 END)          as student_attendance_rate
                                   FROM public.companion_student_map csm
                                            LEFT JOIN public.student_attendance sa
                                                      ON csm.student_id = sa.student_id
                                   GROUP BY csm.headquarter_id, csm.companion_id),
             hq_metrics AS (SELECT h.id                            as hq_id,
                                   h.name                          as hq_name,
                                   COUNT(DISTINCT cm.companion_id) as active_companions,
                                   AVG(cm.assigned_students)       as avg_students_per_companion,
                                   AVG(cm.student_attendance_rate) as avg_student_attendance_rate
                            FROM public.headquarters h
                                     LEFT JOIN companion_metrics cm ON h.id = cm.headquarter_id
                            GROUP BY h.id, h.name)
        SELECT jsonb_agg(
                       jsonb_build_object(
                               'headquarter_id', hm.hq_id,
                               'headquarter_name', hm.hq_name,
                               'active_companions', COALESCE(hm.active_companions, 0),
                               'avg_students_per_companion',
                               ROUND(COALESCE(hm.avg_students_per_companion, 0), 2),
                               'avg_student_attendance_rate',
                               ROUND(COALESCE(hm.avg_student_attendance_rate, 0), 2)
                       )
                       ORDER BY COALESCE(hm.avg_student_attendance_rate, 0) DESC
               )
        INTO result_data
        FROM hq_metrics hm;
    ELSE
        -- HQ-specific companion metrics
        WITH companion_metrics AS (SELECT csm.companion_id,
                                          a.name || ' ' || a.last_name   as companion_name,
                                          COUNT(DISTINCT csm.student_id) as assigned_students,
                                          AVG(CASE
                                                  WHEN sa.attendance_status = 'present' THEN 100.0
                                                  ELSE 0.0 END)          as student_attendance_rate
                                   FROM public.companion_student_map csm
                                            JOIN public.agreements a ON csm.companion_id = a.user_id
                                            LEFT JOIN public.student_attendance sa
                                                      ON csm.student_id = sa.student_id
                                   WHERE csm.headquarter_id = target_hq_id
                                   GROUP BY csm.companion_id, companion_name),
             hq_summary AS (SELECT COUNT(DISTINCT cm.companion_id) as active_companions,
                                   AVG(cm.assigned_students)       as avg_students_per_companion,
                                   AVG(cm.student_attendance_rate) as avg_student_attendance_rate
                            FROM companion_metrics cm)
        SELECT jsonb_build_object(
                       'headquarter_id', target_hq_id,
                       'headquarter_name', h.name,
                       'active_companions', COALESCE(hs.active_companions, 0),
                       'avg_students_per_companion',
                       ROUND(COALESCE(hs.avg_students_per_companion, 0), 2),
                       'avg_student_attendance_rate',
                       ROUND(COALESCE(hs.avg_student_attendance_rate, 0), 2),
                       'companion_details', COALESCE(
                               (SELECT jsonb_agg(
                                               jsonb_build_object(
                                                       'companion_id', cm.companion_id,
                                                       'companion_name', cm.companion_name,
                                                       'assigned_students', cm.assigned_students,
                                                       'student_attendance_rate',
                                                       ROUND(COALESCE(cm.student_attendance_rate, 0), 2)
                                               )
                                               ORDER BY cm.student_attendance_rate DESC
                                       )
                                FROM companion_metrics cm),
                               '[]'::jsonb
                                            )
               )
        INTO result_data
        FROM public.headquarters h
                 LEFT JOIN hq_summary hs ON TRUE
        WHERE h.id = target_hq_id;
    END IF;

    RETURN result_data;
END;
$$;

-- Grant execute permission
GRANT EXECUTE ON FUNCTION get_companion_effectiveness_metrics(uuid) TO authenticated;


================================================================================
File: events.sql
Size: 2.49 kB
================================================================================

-- Events table definition
CREATE TABLE events (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    title TEXT NOT NULL,
    description TEXT,
    headquarter_id UUID REFERENCES headquarters(id) ON DELETE RESTRICT,
    season_id UUID REFERENCES seasons(id) ON DELETE RESTRICT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    start_datetime TIMESTAMPTZ,
    end_datetime TIMESTAMPTZ,
    data JSONB,
    status TEXT CHECK (status IN ('draft', 'scheduled', 'completed', 'cancelled')) DEFAULT 'draft', -- SUGGESTION: Consider ENUM for status for type safety.

    event_type_id integer REFERENCES event_types(id) ON DELETE RESTRICT
);

CREATE TRIGGER handle_updated_at_events
    BEFORE UPDATE ON events
    FOR EACH ROW EXECUTE PROCEDURE moddatetime(updated_at);

CREATE INDEX idx_events_headquarter_id ON events(headquarter_id); -- Support HQ-based queries
CREATE INDEX idx_events_status ON events(status); -- Support status filtering
CREATE INDEX idx_events_start_datetime ON events(start_datetime); -- Support time-based queries
CREATE INDEX idx_events_event_type_id ON events (event_type_id);
CREATE INDEX idx_events_season_id ON events (season_id);

ALTER TABLE events ENABLE ROW LEVEL SECURITY;

-- Policies for the events table

-- SELECT: Authenticated users in their HQ, or konsejo_member_or_higher anywhere
CREATE POLICY events_select_auth_hq
ON events FOR SELECT
TO authenticated
USING (
    headquarter_id = fn_get_current_hq_id() OR
    fn_is_konsejo_member_or_higher()
);

-- INSERT: collaborator_or_higher+ for own HQ, konsejo_member_or_higher for any HQ
-- Collaborators can create events of type 'companion-activity' for example
CREATE POLICY events_insert_collaborator_konsejo
ON events FOR INSERT
WITH CHECK (
    (fn_is_collaborator_or_higher() AND headquarter_id = fn_get_current_hq_id()) OR
    fn_is_konsejo_member_or_higher()
);

-- UPDATE: collaborator_or_higher+ for own HQ, konsejo_member_or_higher for any HQ
CREATE POLICY events_update_collaborator_konsejo
ON events FOR UPDATE
USING (
    (fn_is_collaborator_or_higher() AND headquarter_id = fn_get_current_hq_id()) OR
    fn_is_konsejo_member_or_higher()
)WITH CHECK (
    -- Can only change HQ/Season if Konsejo Member+
    (headquarter_id = headquarter_id AND season_id = season_id)
    OR
    fn_is_konsejo_member_or_higher()
);

-- DELETE: Director+ only
CREATE POLICY events_delete_director
ON events FOR DELETE
USING ( fn_is_general_director_or_higher() );


================================================================================
File: event_types.sql
Size: 1.7 kB
================================================================================

-- schemas/event_types.sql

CREATE TABLE event_types (
    id SERIAL PRIMARY KEY,
    name TEXT NOT NULL UNIQUE,
    description TEXT,
    title TEXT NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    updated_at TIMESTAMPTZ
);

COMMENT ON TABLE event_types IS 'Defines the categories or types of events.';
CREATE INDEX idx_event_types_name ON event_types(name); -- Support fast lookup by name
-- SUGGESTION: If status or similar field is added, consider ENUM for type safety.
COMMENT ON COLUMN event_types.name IS 'Unique name for the event type (e.g., ''Companion Activity'', ''HQ Meeting'').';
COMMENT ON COLUMN event_types.description IS 'Optional longer description of the event type.';
COMMENT ON COLUMN event_types.title IS 'Title for the event type.';

CREATE TRIGGER handle_updated_at_event_types
    BEFORE UPDATE ON event_types
    FOR EACH ROW EXECUTE PROCEDURE moddatetime(updated_at);

ALTER TABLE event_types ENABLE ROW LEVEL SECURITY;


-- SELECT: Allow all authenticated users to view event types
CREATE POLICY event_types_select_authenticated
ON event_types FOR SELECT
TO authenticated
USING (true);

-- INSERT: Restrict to Konsejo Member+ (or adjust level as needed)
CREATE POLICY event_types_insert_high_level
ON event_types FOR INSERT
WITH CHECK ( fn_is_konsejo_member_or_higher() );

-- UPDATE: Restrict to Konsejo Member+
CREATE POLICY event_types_update_high_level
ON event_types FOR UPDATE
USING ( fn_is_konsejo_member_or_higher() )
WITH CHECK ( fn_is_konsejo_member_or_higher() );

-- DELETE: Restrict to Konsejo Member+ (or perhaps Super Admin)
CREATE POLICY event_types_delete_high_level
ON event_types FOR DELETE
USING ( fn_is_konsejo_member_or_higher() );


================================================================================
File: extensions.sql
Size: 161 B
================================================================================

-- Extensions necessary for the Akademia database
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "moddatetime" SCHEMA extensions;


================================================================================
File: facilitator_workshop_map.sql
Size: 5.52 kB
================================================================================

-- schemas/facilitator_workshop_map.sql

CREATE TABLE facilitator_workshop_map (
    facilitator_id uuid NOT NULL REFERENCES collaborators(user_id) ON DELETE CASCADE,
    workshop_id uuid NOT NULL REFERENCES scheduled_workshops(id) ON DELETE CASCADE,
    headquarter_id uuid NOT NULL REFERENCES headquarters(id) ON DELETE RESTRICT, 
    season_id uuid NOT NULL REFERENCES seasons(id) ON DELETE CASCADE, 
    created_at timestamptz DEFAULT now() NOT NULL,
    updated_at timestamptz,
    -- PRIMARY KEY
    CONSTRAINT facilitator_workshop_map_pkey PRIMARY KEY (facilitator_id, workshop_id, season_id, headquarter_id) -- PK ensures uniqueness
);

-- TRIGGER: Enforce consistency between facilitator, workshop, HQ, and season
CREATE OR REPLACE FUNCTION check_facilitator_workshop_map_consistency()
RETURNS TRIGGER 
SET search_path = ''
AS $$
DECLARE
    facilitator_hq_id UUID;
    workshop_hq_id UUID;
    workshop_season_id UUID;
BEGIN
    -- Get facilitator's HQ
    SELECT c.headquarter_id INTO facilitator_hq_id
    FROM public.collaborators c
    WHERE c.user_id = NEW.facilitator_id
    LIMIT 1;

    -- Get workshop's HQ and season
    SELECT w.headquarter_id, w.season_id INTO workshop_hq_id, workshop_season_id
    FROM public.scheduled_workshops w
    WHERE w.id = NEW.workshop_id
    LIMIT 1;

    IF NEW.headquarter_id IS DISTINCT FROM facilitator_hq_id THEN
        RAISE EXCEPTION 'Facilitator HQ (%) does not match mapping HQ (%)', facilitator_hq_id, NEW.headquarter_id;
    END IF;
    IF NEW.headquarter_id IS DISTINCT FROM workshop_hq_id THEN
        RAISE EXCEPTION 'Workshop HQ (%) does not match mapping HQ (%)', workshop_hq_id, NEW.headquarter_id;
    END IF;
    IF NEW.season_id IS DISTINCT FROM workshop_season_id THEN
        RAISE EXCEPTION 'Workshop season (%) does not match mapping season (%)', workshop_season_id, NEW.season_id;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY INVOKER;

CREATE TRIGGER ensure_facilitator_workshop_map_consistency
    BEFORE INSERT OR UPDATE ON facilitator_workshop_map
    FOR EACH ROW EXECUTE FUNCTION check_facilitator_workshop_map_consistency();


COMMENT ON TABLE facilitator_workshop_map IS 'Maps facilitators to scheduled_workshops for a specific season and headquarter.';
COMMENT ON COLUMN facilitator_workshop_map.headquarter_id IS 'The headquarter this mapping belongs to.';
COMMENT ON COLUMN facilitator_workshop_map.season_id IS 'The season this mapping belongs to.';

-- INDEXES
CREATE INDEX idx_facilitator_workshop_map_facilitator_id ON facilitator_workshop_map(facilitator_id);
CREATE INDEX idx_facilitator_workshop_map_workshop_id ON facilitator_workshop_map(workshop_id);
CREATE INDEX idx_facilitator_workshop_map_headquarter_id ON facilitator_workshop_map(headquarter_id); 
CREATE INDEX idx_facilitator_workshop_map_season_id ON facilitator_workshop_map(season_id); 

-- COMPOSITE INDEXES
CREATE INDEX idx_facilitator_workshop_map_headquarter_season ON facilitator_workshop_map(headquarter_id, season_id);
CREATE INDEX idx_facilitator_workshop_map_facilitator_season ON facilitator_workshop_map(facilitator_id, season_id);
CREATE INDEX idx_facilitator_workshop_map_workshop_season ON facilitator_workshop_map(workshop_id, season_id);
CREATE INDEX idx_facilitator_workshop_map_headquarter_workshop ON facilitator_workshop_map(headquarter_id, workshop_id);
CREATE INDEX idx_facilitator_workshop_map_facilitator_workshop ON facilitator_workshop_map(facilitator_id, workshop_id);
CREATE INDEX idx_facilitator_workshop_map_headquarter_facilitator ON facilitator_workshop_map(headquarter_id, facilitator_id);

-- RLS
ALTER TABLE facilitator_workshop_map ENABLE ROW LEVEL SECURITY;

-- POLICIES
-- SELECT Policy:
-- Facilitator sees their own maps.
-- Manager Assistant+ sees all maps for their HQ (all seasons).
-- Director+ sees all maps for all HQs (all seasons).
CREATE POLICY select_facilitator_map
ON facilitator_workshop_map FOR SELECT
USING (
    (select auth.uid())= facilitator_id
    OR
    (fn_is_manager_assistant_or_higher() AND headquarter_id = fn_get_current_hq_id())
    OR
    fn_is_general_director_or_higher()
);

-- INSERT Policy:
-- Manager Assistant+ can insert maps for their HQ.
-- Director+ can insert maps for any HQ.
CREATE POLICY insert_facilitator_map
ON facilitator_workshop_map FOR INSERT
WITH CHECK (
    (fn_is_manager_assistant_or_higher() AND headquarter_id = fn_get_current_hq_id())
    OR
    fn_is_general_director_or_higher()
);

-- UPDATE Policy:
-- Manager Assistant+ can update maps for their HQ.
-- Director+ can update maps for any HQ.
-- Prevent changing key identifiers unless Director+
CREATE POLICY update_facilitator_map
ON facilitator_workshop_map FOR UPDATE
USING (
    (fn_is_manager_assistant_or_higher() AND headquarter_id = fn_get_current_hq_id())
    OR
    fn_is_general_director_or_higher()
)
WITH CHECK (
    -- Ensure the HQ/Season isn't changed unless by Director+
    (headquarter_id = headquarter_id AND season_id = season_id)
    OR
    fn_is_general_director_or_higher()
);


-- DELETE Policy:
-- Manager Assistant+ can delete maps from their HQ.
-- Director+ can delete maps from any HQ.
CREATE POLICY delete_facilitator_map
ON facilitator_workshop_map FOR DELETE
USING (
    (fn_is_manager_assistant_or_higher() AND headquarter_id = fn_get_current_hq_id())
    OR
    fn_is_general_director_or_higher()
);

-- Ensure updated_at is set
CREATE TRIGGER handle_updated_at BEFORE UPDATE ON facilitator_workshop_map
  FOR EACH ROW EXECUTE PROCEDURE moddatetime (updated_at);


================================================================================
File: headquarters.sql
Size: 1.61 kB
================================================================================

-- Headquarters table definition
CREATE TABLE headquarters (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    country_id UUID REFERENCES countries(id) ON DELETE RESTRICT,
    address TEXT,
    contact_info JSONB DEFAULT '{}',
    status TEXT CHECK (status IN ('active', 'inactive')) DEFAULT 'active', -- SUGGESTION: Consider ENUM for status for type safety.
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TRIGGER handle_updated_at_headquarters
    BEFORE UPDATE ON headquarters
    FOR EACH ROW EXECUTE PROCEDURE moddatetime(updated_at);

CREATE INDEX idx_headquarters_country_id ON headquarters(country_id); -- Support country-based queries

-- Enable Row Level Security
ALTER TABLE headquarters ENABLE ROW LEVEL SECURITY;

-- Policies for the headquarters table

-- SELECT: Allow any authenticated user to view headquarters
CREATE POLICY hq_select_auth
ON headquarters FOR SELECT
TO authenticated
USING (true OR fn_is_general_director_or_higher());

-- INSERT: Allow only general directors or higher
CREATE POLICY hq_insert_high_level
ON headquarters FOR INSERT
TO authenticated
WITH CHECK ( fn_is_general_director_or_higher() );

-- UPDATE: Allow only general directors or higher
CREATE POLICY hq_update_high_level
ON headquarters FOR UPDATE
TO authenticated
USING ( fn_is_general_director_or_higher() )
WITH CHECK ( fn_is_general_director_or_higher() );

-- DELETE: Allow only general directors or higher
CREATE POLICY hq_delete_high_level
ON headquarters FOR DELETE
TO authenticated
USING ( fn_is_general_director_or_higher() );


================================================================================
File: master_workshop_types.sql
Size: 1.99 kB
================================================================================

-- schemas/master_workshop_types.sql

CREATE TABLE master_workshop_types (
    id SERIAL PRIMARY KEY,
    master_name TEXT NOT NULL UNIQUE, -- Official name from General Direction
    master_description TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    updated_at TIMESTAMPTZ
);

COMMENT ON TABLE master_workshop_types IS 'Central catalog of standardized workshop types offered by the General Direction.';
COMMENT ON COLUMN master_workshop_types.master_name IS 'The official, unique name of the workshop template.';
COMMENT ON COLUMN master_workshop_types.master_description IS 'Detailed description of the master workshop template.';

CREATE TRIGGER handle_updated_at_master_workshop_types
    BEFORE UPDATE ON master_workshop_types
    FOR EACH ROW EXECUTE PROCEDURE moddatetime(updated_at);
-- SUGGESTION: If status or similar field is added, consider ENUM for type safety.

-- Enable Row Level Security
ALTER TABLE master_workshop_types ENABLE ROW LEVEL SECURITY;

-- Policies: Allow viewing by authenticated, management by high roles (e.g., Super Admin)
CREATE POLICY master_workshop_types_select_auth
    ON master_workshop_types FOR SELECT
    TO authenticated USING (true);

-- INSERT: Allow only super admins
CREATE POLICY master_workshop_types_insert_superadmin
    ON master_workshop_types FOR INSERT
    TO authenticated
    WITH CHECK ( fn_is_general_director_or_higher() ); -- Only Super Admins can insert master types

-- UPDATE: Allow only super admins
CREATE POLICY master_workshop_types_update_superadmin
    ON master_workshop_types FOR UPDATE
    TO authenticated
    USING ( fn_is_general_director_or_higher() ) -- Only Super Admins can update master types
    WITH CHECK ( fn_is_general_director_or_higher() );

-- DELETE: Allow only super admins
CREATE POLICY master_workshop_types_delete_superadmin
    ON master_workshop_types FOR DELETE
    TO authenticated
    USING ( fn_is_general_director_or_higher() ); -- Only Super Admins can delete master types


================================================================================
File: processes.sql
Size: 1.5 kB
================================================================================

-- Processes table definition
CREATE TABLE processes (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    name VARCHAR(50) NOT NULL,
    description TEXT,
    type TEXT,
    status TEXT CHECK (status IN ('active', 'inactive')) DEFAULT 'active', -- SUGGESTION: Consider ENUM for status for type safety.
    version TEXT,
    content JSONB,
    required_approvals UUID[]
);

CREATE TRIGGER handle_updated_at_processes
    BEFORE UPDATE ON processes
    FOR EACH ROW EXECUTE PROCEDURE moddatetime(updated_at);

CREATE INDEX idx_processes_status ON processes(status); -- Support status filtering

-- Enable Row Level Security
ALTER TABLE processes ENABLE ROW LEVEL SECURITY;

-- Create policies for authenticated users
-- SELECT policy
CREATE POLICY "Allow authenticated users to view processes"
ON processes
FOR SELECT
TO authenticated
USING (true);

-- INSERT: Allow only high-level roles
CREATE POLICY processes_insert_high_level
ON processes FOR INSERT
TO authenticated
WITH CHECK ( fn_is_general_director_or_higher() );

-- UPDATE: Allow only high-level roles
CREATE POLICY processes_update_high_level
ON processes FOR UPDATE
TO authenticated
USING ( fn_is_general_director_or_higher() )
WITH CHECK ( fn_is_general_director_or_higher() );

-- DELETE: Allow only high-level roles
CREATE POLICY processes_delete_high_level
ON processes FOR DELETE
TO authenticated
USING ( fn_is_general_director_or_higher() );


================================================================================
File: rbac_helpers.sql
Size: 4.72 kB
================================================================================

-- Helper functions for Role-Based Access Control (RBAC)
-- Super administrador	100
-- Director General	95
-- Lder Ejecutivo	90
-- Lder Pedaggico	90
-- Lder de Comunicacin	90
-- Lder de Koordinacin	90
-- Lder de Innovacin	80
-- Lder de Komunidad	80
-- Fundacin Utpika	80
-- Koordinador	80
-- Asesor Legal	80
-- Miembro del Konsejo de Direccin	80
-- Director/a Local	50
-- Director/a Pedaggico Local	50
-- Director/a de Comunicacin Local	50
-- Director/a de Acompaantes Local	50
-- Asistente a la direccin	30
-- Acompaante	20
-- Facilitador	20
-- Alumno	1

-- Function to safely get the entire metadata object for the current user
CREATE OR REPLACE FUNCTION fn_get_current_user_metadata()
    RETURNS jsonb
    LANGUAGE sql
    STABLE SECURITY DEFINER SET search_path = ''
AS
$$
SELECT COALESCE(raw_user_meta_data, '{}'::jsonb)
FROM auth.users
WHERE id = auth.uid();
$$;


-- Function to get the current user's role code
CREATE OR REPLACE FUNCTION fn_get_current_role_code()
    RETURNS text
    LANGUAGE sql
    STABLE SECURITY DEFINER SET search_path = ''
AS
$$
SELECT public.fn_get_current_user_metadata() ->> 'role';
$$;

-- Function to get the current user's role level
CREATE OR REPLACE FUNCTION fn_get_current_role_level()
    RETURNS integer
    LANGUAGE sql
    STABLE SECURITY DEFINER SET search_path = ''
AS
$$
SELECT COALESCE((public.fn_get_current_user_metadata() ->> 'role_level')::integer, 0);
$$;

-- Function to get the current user's role ID
CREATE OR REPLACE FUNCTION fn_get_current_role_id()
    RETURNS uuid
    LANGUAGE sql
    STABLE SECURITY DEFINER SET search_path = ''
AS
$$
SELECT NULLIF(public.fn_get_current_user_metadata() ->> 'role_id', '')::uuid;
$$;

-- Function to get the current user's headquarter ID
CREATE OR REPLACE FUNCTION fn_get_current_hq_id()
    RETURNS uuid
    LANGUAGE sql
    STABLE SECURITY DEFINER SET search_path = ''
AS
$$
SELECT NULLIF(public.fn_get_current_user_metadata() ->> 'hq_id', '')::uuid;
$$;

-- Function to get the current user's season ID
CREATE OR REPLACE FUNCTION fn_get_current_season_id()
    RETURNS uuid
    LANGUAGE sql
    STABLE SECURITY DEFINER SET search_path = ''
AS
$$
SELECT NULLIF(public.fn_get_current_user_metadata() ->> 'season_id', '')::uuid;
$$;

-- Function to get the current user's agreement ID
CREATE OR REPLACE FUNCTION fn_get_current_agreement_id()
    RETURNS uuid
    LANGUAGE sql
    STABLE SECURITY DEFINER SET search_path = ''
AS
$$
SELECT NULLIF(public.fn_get_current_user_metadata() ->> 'agreement_id', '')::uuid;
$$;

--Is super admin
CREATE OR REPLACE FUNCTION fn_is_super_admin()
    RETURNS boolean
    LANGUAGE sql
    STABLE SECURITY DEFINER SET search_path = ''
AS
$$
SELECT public.fn_get_current_role_level() >= 100;
$$;

-- Function that returns true if role is General Director (95+) or higher
CREATE OR REPLACE FUNCTION fn_is_general_director_or_higher()
    RETURNS boolean
    LANGUAGE sql
    STABLE SECURITY DEFINER SET search_path = ''
AS
$$
SELECT public.fn_get_current_role_level() >= 95;
$$;

-- Function that returns true if role is Konsejo member or higher (80+)
CREATE OR REPLACE FUNCTION fn_is_konsejo_member_or_higher()
    RETURNS boolean
    LANGUAGE sql
    STABLE SECURITY DEFINER SET search_path = ''
AS
$$
SELECT public.fn_get_current_role_level() >= 80;
$$;

-- Function that returns true if role is local manager (50+) or higher
CREATE OR REPLACE FUNCTION fn_is_local_manager_or_higher()
    RETURNS boolean
    LANGUAGE sql
    STABLE SECURITY DEFINER SET search_path = ''
AS
$$
SELECT public.fn_get_current_role_level() >= 50;
$$;

-- Function that returns true if role is manager assistant (30+) or higher
CREATE OR REPLACE FUNCTION fn_is_manager_assistant_or_higher()
    RETURNS boolean
    LANGUAGE sql
    STABLE SECURITY DEFINER SET search_path = ''
AS
$$
SELECT public.fn_get_current_role_level() >= 30;
$$;

-- Function that returns true if role is collaborator (20+) or higher
CREATE OR REPLACE FUNCTION fn_is_collaborator_or_higher()
    RETURNS boolean
    LANGUAGE sql
    STABLE SECURITY DEFINER SET search_path = ''
AS
$$
SELECT public.fn_get_current_role_level() >= 20;
$$;

-- Function that returns true if role is student (1+) or higher
CREATE OR REPLACE FUNCTION fn_is_student_or_higher()
    RETURNS boolean
    LANGUAGE sql
    STABLE SECURITY DEFINER SET search_path = ''
AS
$$
SELECT public.fn_get_current_role_level() >= 1;
$$;

-- Function that returns true if the current user hq is the same as the provided hq id
CREATE OR REPLACE FUNCTION fn_is_current_user_hq_equal_to(hq_id uuid)
    RETURNS boolean
    LANGUAGE sql
    STABLE SECURITY DEFINER SET search_path = ''
AS
$$
SELECT public.fn_get_current_hq_id() = hq_id;
$$;



================================================================================
File: roles.sql
Size: 1.79 kB
================================================================================

-- Roles table definition
CREATE TABLE roles (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    code TEXT NOT NULL UNIQUE,
    name TEXT NOT NULL,
    description TEXT,
    status TEXT CHECK (status IN ('active', 'inactive')) DEFAULT 'active', -- SUGGESTION: Consider ENUM for status for type safety.
    level INTEGER NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    permissions JSONB DEFAULT '{}'
);

CREATE TRIGGER handle_updated_at_roles
    BEFORE UPDATE ON roles
    FOR EACH ROW EXECUTE PROCEDURE moddatetime(updated_at);

CREATE INDEX idx_roles_code ON roles(code); -- Support fast lookup by code

-- Enable Row Level Security
ALTER TABLE roles ENABLE ROW LEVEL SECURITY;

-- Policies for the role table

-- SELECT: Allow any authenticated user to view roles
CREATE POLICY roles_select_auth
ON roles FOR SELECT
TO authenticated
USING (true);

-- INSERT: Allow only superadmin roles (>=100)
CREATE POLICY roles_insert_superadmin
ON roles FOR INSERT
TO authenticated
WITH CHECK ( fn_get_current_role_level() >= 100 );

-- UPDATE: Allow only superadmin roles (>=100)
CREATE POLICY roles_update_superadmin
ON roles FOR UPDATE
TO authenticated
USING ( fn_get_current_role_level() >= 100 )
WITH CHECK ( fn_get_current_role_level() >= 100 );

-- DELETE: Allow only superadmin roles (>=100)
CREATE POLICY roles_delete_superadmin
ON roles FOR DELETE
TO authenticated
USING ( fn_get_current_role_level() >= 100 );

CREATE OR REPLACE FUNCTION fn_is_role_level_below(p_role_id UUID, p_level_threshold INT)
    RETURNS BOOLEAN 
    SET search_path = ''
    AS $$
    DECLARE
role_level INT;
BEGIN
SELECT level INTO role_level FROM public.roles WHERE id = p_role_id;
RETURN role_level < p_level_threshold;
END;
    $$ LANGUAGE plpgsql STABLE;


================================================================================
File: scheduled_workshops.sql
Size: 5.01 kB
================================================================================

-- schemas/scheduled_workshops.sql

CREATE TABLE scheduled_workshops (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    master_workshop_type_id INTEGER NOT NULL REFERENCES master_workshop_types(id) ON DELETE RESTRICT,
    headquarter_id UUID NOT NULL REFERENCES headquarters(id) ON DELETE RESTRICT,
    season_id UUID NOT NULL REFERENCES seasons(id) ON DELETE RESTRICT,
    -- Facilitator must be a collaborator from the *same headquarter* (enforced by trigger)
    facilitator_id UUID NOT NULL REFERENCES collaborators(user_id) ON DELETE RESTRICT,
    local_name TEXT NOT NULL, -- HQ-specific name for this instance
    start_datetime TIMESTAMPTZ NOT NULL,
    end_datetime TIMESTAMPTZ NOT NULL,
    location_details TEXT, -- E-g online, at headquarters, outside...
    status TEXT NOT NULL CHECK (status IN ('scheduled', 'completed', 'cancelled')) DEFAULT 'scheduled', -- SUGGESTION: Consider ENUM for status for type safety.
    created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    updated_at TIMESTAMPTZ,
    -- Ensure a specific HQ doesn't schedule the exact same local name twice in one season
    CONSTRAINT uq_local_name_hq_season UNIQUE (local_name, headquarter_id, season_id),
    -- Ensure end time is after start time
    CONSTRAINT chk_workshop_times CHECK (end_datetime > start_datetime)
);

COMMENT ON TABLE scheduled_workshops IS 'Specific instances of scheduled_workshops scheduled by a headquarter for a given season.';
COMMENT ON COLUMN scheduled_workshops.master_workshop_type_id IS 'Link to the master template for this workshop.';
COMMENT ON COLUMN scheduled_workshops.headquarter_id IS 'The HQ that scheduled and is hosting this workshop instance.';
COMMENT ON COLUMN scheduled_workshops.season_id IS 'The season during which this workshop instance takes place.';
COMMENT ON COLUMN scheduled_workshops.facilitator_id IS 'The primary collaborator assigned to facilitate this specific instance.';
COMMENT ON COLUMN scheduled_workshops.local_name IS 'The name given to this workshop instance by the hosting headquarter.';
COMMENT ON COLUMN scheduled_workshops.start_datetime IS 'Start date and time of the workshop instance.';
COMMENT ON COLUMN scheduled_workshops.end_datetime IS 'End date and time of the workshop instance.';
COMMENT ON COLUMN scheduled_workshops.status IS 'The current status of the scheduled workshop instance.';

CREATE INDEX idx_scheduled_workshops_master_type ON scheduled_workshops(master_workshop_type_id); -- Support filtering by type
CREATE INDEX idx_scheduled_workshops_hq ON scheduled_workshops(headquarter_id); -- Support HQ-based queries
CREATE INDEX idx_scheduled_workshops_season ON scheduled_workshops(season_id); -- Support season-based queries
CREATE INDEX idx_scheduled_workshops_facilitator ON scheduled_workshops(facilitator_id); -- Support facilitator-based queries
CREATE INDEX idx_scheduled_workshops_start_time ON scheduled_workshops(start_datetime); -- Support time-based queries

CREATE TRIGGER handle_updated_at_scheduled_workshops
    BEFORE UPDATE ON scheduled_workshops
    FOR EACH ROW EXECUTE PROCEDURE moddatetime(updated_at);

-- Enable Row Level Security
ALTER TABLE scheduled_workshops ENABLE ROW LEVEL SECURITY;

-- RLS Policies (Example - Adjust roles/levels as needed)
-- SELECT: Facilitator sees own, Manager Assistant+ sees own HQ, Director+ sees all
CREATE POLICY scheduled_workshops_select_policy
    ON scheduled_workshops FOR SELECT
    TO authenticated
    USING (
        facilitator_id = (select auth.uid())
        OR
        (fn_is_manager_assistant_or_higher() AND headquarter_id = fn_get_current_hq_id())
        OR
        fn_is_general_director_or_higher()
    );

-- INSERT: Manager Assistant+ for own HQ, Director+ for any
CREATE POLICY scheduled_workshops_insert_policy
    ON scheduled_workshops FOR INSERT
    TO authenticated
    WITH CHECK (
        (fn_is_manager_assistant_or_higher() AND headquarter_id = fn_get_current_hq_id())
        OR
        fn_is_general_director_or_higher()
        -- Trigger will validate facilitator role/HQ
    );

-- UPDATE: Manager Assistant+ for own HQ (no HQ/Season change), Director+ for any (can change HQ/Season)
CREATE POLICY scheduled_workshops_update_policy
    ON scheduled_workshops FOR UPDATE
    TO authenticated
    USING (
        (fn_is_manager_assistant_or_higher() AND headquarter_id = fn_get_current_hq_id())
        OR
        fn_is_general_director_or_higher()
    )
    WITH CHECK (
        (headquarter_id = headquarter_id AND season_id = season_id AND fn_is_manager_assistant_or_higher())
        OR
        fn_is_general_director_or_higher()
        -- Trigger will validate facilitator role/HQ on change
    );

-- DELETE: Manager Assistant+ for own HQ, Director+ for any
CREATE POLICY scheduled_workshops_delete_policy
    ON scheduled_workshops FOR DELETE
    TO authenticated
    USING (
        (fn_is_manager_assistant_or_higher() AND headquarter_id = fn_get_current_hq_id())
        OR
        fn_is_general_director_or_higher()
    );


================================================================================
File: seasons.sql
Size: 3.43 kB
================================================================================

-- Seasons table definition
CREATE TABLE seasons (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    headquarter_id UUID NOT NULL REFERENCES headquarters(id) ON DELETE RESTRICT,
    manager_id UUID NULL REFERENCES collaborators(user_id) ON DELETE SET NULL,
    start_date DATE,
    end_date DATE,
    status TEXT CHECK (status IN ('active', 'inactive', 'completed')) DEFAULT 'inactive', -- SUGGESTION: Consider ENUM for status for type safety.
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    CONSTRAINT unique_season_name_per_hq UNIQUE (name, headquarter_id),
    CONSTRAINT check_season_dates CHECK (end_date IS NULL OR start_date IS NULL OR end_date >= start_date)
);

COMMENT ON TABLE seasons IS 'Defines operational seasons within a headquarter.';
COMMENT ON COLUMN seasons.headquarter_id IS 'The headquarter this season belongs to.';
COMMENT ON COLUMN seasons.manager_id IS 'Optional manager (collaborator) assigned to oversee the season.';
COMMENT ON COLUMN seasons.status IS 'Current status of the season lifecycle.';
COMMENT ON CONSTRAINT unique_season_name_per_hq ON seasons IS 'Ensures season names are unique within each headquarter.';
COMMENT ON CONSTRAINT check_season_dates ON seasons IS 'Ensures end_date is not before start_date.';


CREATE TRIGGER handle_updated_at_seasons
    BEFORE UPDATE ON seasons
    FOR EACH ROW EXECUTE PROCEDURE moddatetime(updated_at);

CREATE INDEX idx_seasons_headquarter_id ON seasons(headquarter_id); -- Support HQ-based queries
CREATE INDEX idx_seasons_manager_id ON seasons(manager_id); -- Support manager-based queries
CREATE INDEX idx_seasons_status ON seasons(status); -- Support status filtering
CREATE INDEX idx_seasons_start_date ON seasons(start_date); -- Support date-based queries

ALTER TABLE seasons ENABLE ROW LEVEL SECURITY;

-- Policies for the seasons table (using helper functions)

-- SELECT policy: View own HQ's seasons or all if Konsejo Member+
CREATE POLICY seasons_select_policy
ON seasons FOR SELECT
TO authenticated
USING (
    headquarter_id = fn_get_current_hq_id()
    OR
    fn_is_konsejo_member_or_higher() -- Konsejo+ can see all
);

-- INSERT policy: Konsejo+ for own HQ, General Director+ for any
CREATE POLICY seasons_insert_policy
ON seasons FOR INSERT
TO authenticated
WITH CHECK (
    (fn_is_konsejo_member_or_higher() AND headquarter_id = fn_get_current_hq_id()) -- Konsejo+ can insert for own HQ
    OR
    fn_is_general_director_or_higher() -- General Director+ can insert for any HQ
);

-- UPDATE policy: Konsejo+ for own HQ (no HQ change), General Director+ for any (can change HQ)
CREATE POLICY seasons_update_policy
ON seasons FOR UPDATE
TO authenticated
USING (
    -- Target rows: Konsejo+ own HQ, or General Director+ any
    (fn_is_konsejo_member_or_higher() AND headquarter_id = fn_get_current_hq_id())
    OR
    fn_is_general_director_or_higher()
)
WITH CHECK (
    -- Check after update: HQ cannot be changed unless user is General Director+
    (headquarter_id = headquarter_id AND fn_is_konsejo_member_or_higher()) -- Konsejo+ can update if HQ doesn't change
    OR
    fn_is_general_director_or_higher() -- General Director+ can update and change HQ
);

-- DELETE policy: General Director+ only
CREATE POLICY seasons_delete_policy
ON seasons FOR DELETE
TO authenticated
USING (
    fn_is_general_director_or_higher() -- Only General Director+ can delete
);


================================================================================
File: strapi_migrations.sql
Size: 1.67 kB
================================================================================

CREATE TABLE strapi_migrations (
    id BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    migration_timestamp TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    last_migrated_at TIMESTAMPTZ NOT NULL,
    status TEXT NOT NULL CHECK (status IN ('success', 'failed')),
    records_processed INTEGER NOT NULL DEFAULT 0,
    error_message TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add comment to the table
COMMENT ON TABLE strapi_migrations IS 'Tracks Strapi to Supabase migration runs';

-- Add comments to columns
COMMENT ON COLUMN strapi_migrations.id IS 'Unique identifier for each migration run';
COMMENT ON COLUMN strapi_migrations.migration_timestamp IS 'When the migration was executed';
COMMENT ON COLUMN strapi_migrations.last_migrated_at IS 'Timestamp of the last successfully migrated record';
COMMENT ON COLUMN strapi_migrations.status IS 'Status of the migration (success/failed)';
COMMENT ON COLUMN strapi_migrations.records_processed IS 'Number of records processed in this migration';
COMMENT ON COLUMN strapi_migrations.error_message IS 'Error message if migration failed';
COMMENT ON COLUMN strapi_migrations.created_at IS 'When this record was created';

-- Add RLS policies
ALTER TABLE strapi_migrations ENABLE ROW LEVEL SECURITY;

-- Allow authenticated users to view migration history
CREATE POLICY "Allow authenticated users to view migration history" 
ON strapi_migrations FOR SELECT 
TO authenticated 
USING (true);

-- Allow service role to insert new migration records
CREATE POLICY "Allow service role to insert migration records" 
ON strapi_migrations FOR INSERT 
TO service_role 
WITH CHECK (true);

================================================================================
File: students.sql
Size: 1.85 kB
================================================================================

-- Students table definition
CREATE TABLE students (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL UNIQUE REFERENCES auth.users(id) ON DELETE CASCADE,
    headquarter_id UUID NOT NULL REFERENCES headquarters(id) ON DELETE RESTRICT,
    season_id UUID NOT NULL REFERENCES seasons(id) ON DELETE RESTRICT,
    enrollment_date DATE NOT NULL,
    status TEXT CHECK (status IN ('active', 'prospect', 'graduated', 'inactive')) DEFAULT 'prospect',
    program_progress_comments JSONB
);

CREATE INDEX idx_students_user_id ON students(user_id);
CREATE INDEX idx_students_headquarter_id ON students(headquarter_id);
CREATE INDEX idx_students_season_id ON students(season_id);

-- Enable Row Level Security
ALTER TABLE students ENABLE ROW LEVEL SECURITY;

-- Policies for the students table

-- SELECT: Own record, high level (>=80), same HQ, or assigned mentor/facilitator
CREATE POLICY students_select_own_hq_high_mentor
ON students FOR SELECT
USING (
    user_id = (select auth.uid()) OR
    fn_get_current_role_level() >= 80 OR
    headquarter_id = fn_get_current_hq_id()
    -- todo
);

-- INSERT: Allow manager+ (>=40) to insert
CREATE POLICY students_insert_manager
ON students FOR INSERT
WITH CHECK ( fn_get_current_role_level() >= 40 );

-- UPDATE: Manager+ (>=40) or assigned mentor
CREATE POLICY students_update_manager_mentor
ON students FOR UPDATE
USING (
    fn_get_current_role_level() >= 40
    -- TODO: Add logic for assigned mentors
    -- Example:
    -- OR id IN (SELECT student_id FROM companion_student_map WHERE companion_id = fn_get_current_collaborator_id())
)
WITH CHECK (
    fn_get_current_role_level() >= 40
    -- Add specific field checks here if needed
);

-- DELETE: Admin only (>=100)
CREATE POLICY students_delete_admin
ON students FOR DELETE
USING ( fn_get_current_role_level() >= 100 );


================================================================================
File: student_attendance.sql
Size: 6.06 kB
================================================================================

-- schemas/student_attendance.sql

CREATE TABLE student_attendance (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    scheduled_workshop_id UUID NOT NULL REFERENCES scheduled_workshops(id) ON DELETE CASCADE, -- Cascade delete if workshop instance deleted
    student_id UUID NOT NULL REFERENCES students(user_id) ON DELETE CASCADE, -- Cascade delete if student deleted
    attendance_status TEXT NOT NULL CHECK (attendance_status IN ('present', 'absent')),
    attendance_timestamp TIMESTAMPTZ DEFAULT NOW() NOT NULL, -- When the record was created/marked
    notes TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    updated_at TIMESTAMPTZ,
    -- A student can only have one attendance status record per workshop instance
    CONSTRAINT uq_student_workshop_attendance UNIQUE (scheduled_workshop_id, student_id)
);

COMMENT ON TABLE student_attendance IS 'Tracks student attendance for specific scheduled workshop instances.';
COMMENT ON COLUMN student_attendance.scheduled_workshop_id IS 'The specific workshop instance attended.';
COMMENT ON COLUMN student_attendance.student_id IS 'The student whose attendance is being tracked.';
COMMENT ON COLUMN student_attendance.attendance_status IS 'Attendance status (present, absent, excused).';
COMMENT ON COLUMN student_attendance.attendance_timestamp IS 'Timestamp when attendance was recorded.';

CREATE INDEX idx_student_attendance_workshop ON student_attendance(scheduled_workshop_id);
CREATE INDEX idx_student_attendance_student ON student_attendance(student_id);

CREATE TRIGGER handle_updated_at_student_attendance
    BEFORE UPDATE ON student_attendance
    FOR EACH ROW EXECUTE PROCEDURE moddatetime(updated_at);

-- Enable Row Level Security
ALTER TABLE student_attendance ENABLE ROW LEVEL SECURITY;

-- RLS Policies (Example - Adjust as needed)
-- SELECT: Student sees own, Facilitator sees own workshop's, Manager Assistant+ sees own HQ's, Director+ sees all
CREATE POLICY student_attendance_select_policy
    ON student_attendance FOR SELECT
    TO authenticated
    USING (
        student_id =(select auth.uid()) -- Student sees their own records
        OR
        -- Facilitator sees attendance for scheduled_workshops they facilitate
        EXISTS (
            SELECT 1 FROM scheduled_workshops sw
            WHERE sw.id = student_attendance.scheduled_workshop_id AND sw.facilitator_id = (select auth.uid())
        )
        OR
        -- Manager Assistant+ sees attendance for scheduled_workshops in their HQ
        (fn_is_manager_assistant_or_higher() AND EXISTS (
            SELECT 1 FROM scheduled_workshops sw
            WHERE sw.id = student_attendance.scheduled_workshop_id AND sw.headquarter_id = fn_get_current_hq_id()
        ))
        OR
        fn_is_general_director_or_higher() -- Director+ sees all
    );

-- INSERT: Facilitator for own workshop, Manager Assistant+ for own HQ, Director+ for any
CREATE POLICY student_attendance_insert_policy
    ON student_attendance FOR INSERT
    TO authenticated
    WITH CHECK (
        -- Facilitator managing attendance for scheduled_workshops they facilitate
        EXISTS (
            SELECT 1 FROM scheduled_workshops sw
            WHERE sw.id = student_attendance.scheduled_workshop_id AND sw.facilitator_id = (select auth.uid())
        )
        OR
        -- Manager Assistant+ managing attendance for scheduled_workshops in their HQ
        (fn_is_manager_assistant_or_higher() AND EXISTS (
            SELECT 1 FROM scheduled_workshops sw
            WHERE sw.id = student_attendance.scheduled_workshop_id AND sw.headquarter_id = fn_get_current_hq_id()
        ))
        OR
        fn_is_general_director_or_higher() -- Director+ managing all
    );

-- UPDATE: Facilitator for own workshop, Manager Assistant+ for own HQ, Director+ for any
CREATE POLICY student_attendance_update_policy
    ON student_attendance FOR UPDATE
    TO authenticated
    USING (
        -- Facilitator managing attendance for scheduled_workshops they facilitate
        EXISTS (
            SELECT 1 FROM scheduled_workshops sw
            WHERE sw.id = student_attendance.scheduled_workshop_id AND sw.facilitator_id = (select auth.uid())
        )
        OR
        -- Manager Assistant+ managing attendance for scheduled_workshops in their HQ
        (fn_is_manager_assistant_or_higher() AND EXISTS (
            SELECT 1 FROM scheduled_workshops sw
            WHERE sw.id = student_attendance.scheduled_workshop_id AND sw.headquarter_id = fn_get_current_hq_id()
        ))
        OR
        fn_is_general_director_or_higher() -- Director+ managing all
    )
    WITH CHECK (
        -- Same check logic as USING for simplicity here
        EXISTS (
            SELECT 1 FROM scheduled_workshops sw
            WHERE sw.id = student_attendance.scheduled_workshop_id AND sw.facilitator_id = (select auth.uid())
        )
        OR
        (fn_is_manager_assistant_or_higher() AND EXISTS (
            SELECT 1 FROM scheduled_workshops sw
            WHERE sw.id = student_attendance.scheduled_workshop_id AND sw.headquarter_id = fn_get_current_hq_id()
        ))
        OR
        fn_is_general_director_or_higher()
    );

-- DELETE: Facilitator for own workshop, Manager Assistant+ for own HQ, Director+ for any
CREATE POLICY student_attendance_delete_policy
    ON student_attendance FOR DELETE
    TO authenticated
    USING (
        -- Facilitator managing attendance for scheduled_workshops they facilitate
        EXISTS (
            SELECT 1 FROM scheduled_workshops sw
            WHERE sw.id = student_attendance.scheduled_workshop_id AND sw.facilitator_id = (select auth.uid())
        )
        OR
        -- Manager Assistant+ managing attendance for scheduled_workshops in their HQ
        (fn_is_manager_assistant_or_higher() AND EXISTS (
            SELECT 1 FROM scheduled_workshops sw
            WHERE sw.id = student_attendance.scheduled_workshop_id AND sw.headquarter_id = fn_get_current_hq_id()
        ))
        OR
        fn_is_general_director_or_higher() -- Director+ managing all
    );


================================================================================
File: workshop_triggers.sql
Size: 2.34 kB
================================================================================

-- schemas/workshop_triggers.sql

-- Function to check if a user is a valid facilitator for a given HQ
-- Assumes 'collaborators' table links user_id to role_id and headquarter_id
CREATE OR REPLACE FUNCTION fn_is_valid_facilitator_for_hq(p_user_id uuid, p_headquarter_id uuid)
RETURNS boolean
LANGUAGE plpgsql STABLE SECURITY INVOKER
SET search_path = ''
AS $$
DECLARE
    is_valid boolean := false;
    facilitator_role_level integer := 20;
BEGIN
    -- Check if a collaborator exists, belongs to the HQ, and has the facilitator role level
    SELECT EXISTS (
        SELECT 1
        FROM public.collaborators c
        JOIN public.roles r ON c.role_id = r.id
        WHERE c.user_id = p_user_id
          AND c.headquarter_id = p_headquarter_id
          AND r.level >= facilitator_role_level
    ) INTO is_valid;
    RETURN is_valid;
END;
$$;

COMMENT ON FUNCTION fn_is_valid_facilitator_for_hq(uuid, uuid) IS 'Checks if a given user_id is a collaborator with facilitator role level (or higher) within the specified headquarter_id.';

-- Trigger function to validate facilitator on workshop schedule/update
CREATE OR REPLACE FUNCTION trigger_validate_workshop_facilitator()
RETURNS TRIGGER 
SET search_path = ''
AS $$
BEGIN
    -- Check on INSERT or if facilitator_id or headquarter_id is changed on UPDATE
    IF TG_OP = 'INSERT' OR (TG_OP = 'UPDATE' AND (NEW.facilitator_id IS DISTINCT FROM OLD.facilitator_id OR NEW.headquarter_id IS DISTINCT FROM OLD.headquarter_id)) THEN
        IF NOT public.fn_is_valid_facilitator_for_hq(NEW.facilitator_id, NEW.headquarter_id) THEN
            RAISE EXCEPTION 'User ID % is not a valid facilitator for headquarter ID %.', NEW.facilitator_id, NEW.headquarter_id;
        END IF;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

COMMENT ON FUNCTION trigger_validate_workshop_facilitator() IS 'Trigger function for scheduled_workshops table to ensure the assigned facilitator_id is valid for the specified headquarter_id.';

DROP TRIGGER IF EXISTS validate_facilitator_before_insert_update ON scheduled_workshops;

CREATE TRIGGER validate_facilitator_before_insert_update
    BEFORE INSERT OR UPDATE ON scheduled_workshops
    FOR EACH ROW EXECUTE FUNCTION trigger_validate_workshop_facilitator();

GRANT EXECUTE ON FUNCTION fn_is_valid_facilitator_for_hq(uuid, uuid) TO authenticated;

